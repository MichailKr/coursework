
==================== camera.py ====================

import pygame
from pygame.math import Vector2

class Camera:
    def __init__(self, width, height):
        """
        Инициализация камеры
        Args:
            width (int): Ширина видимой области (экрана)
            height (int): Высота видимой области (экрана)
        """
        self.width = width
        self.height = height
        self.offset = Vector2(0, 0)
        self.map_width = 0
        self.map_height = 0
        print("Камера инициализирована")

    def set_map_size(self, width, height):
        """Установка размеров карты для ограничения движения камеры"""
        self.map_width = width
        self.map_height = height
        print(f"Установлены размеры карты для камеры: {width}x{height}")

    def apply(self, entity):
        """
        Применяет смещение камеры к позиции объекта
        Args:
            entity: Объект с атрибутом rect
        Returns:
            pygame.Rect: Новый прямоугольник с учетом смещения камеры
        """
        return pygame.Rect(
            entity.rect.x - int(self.offset.x),
            entity.rect.y - int(self.offset.y),
            entity.rect.width,
            entity.rect.height
        )

    def apply_rect(self, rect):
        """Применяет смещение камеры к прямоугольнику"""
        return pygame.Rect(
            rect.x - int(self.offset.x),
            rect.y - int(self.offset.y),
            rect.width,
            rect.height
        )

    def apply_point(self, x, y):
        """Применяет смещение камеры к точке"""
        return (x - int(self.offset.x), y - int(self.offset.y))

    def update(self, target):
        """
        Обновляет позицию камеры, чтобы следовать за целью
        Args:
            target: Объект, за которым следует камера (обычно игрок)
        """
        # Вычисляем желаемое смещение камеры
        self.offset.x = target.rect.centerx - self.width // 2
        self.offset.y = target.rect.centery - self.height // 2

        # Ограничиваем смещение камеры границами карты
        self.offset.x = max(0, min(self.offset.x, self.map_width - self.width))
        self.offset.y = max(0, min(self.offset.y, self.map_height - self.height))



==================== collect.py ====================

import glob


def main():
    with open('../output.txt', 'w', encoding='utf-8') as outfile:
        # Собираем все .php и .css файлы
        for filename in glob.glob('*.py'):
            # Записываем название файла
            outfile.write(f"\n{'=' * 20} {filename} {'=' * 20}\n\n")

            try:
                # Читаем содержимое файла
                with open(filename, 'r', encoding='utf-8') as infile:
                    content = infile.read()
                    # Записываем содержимое в выходной файл
                    outfile.write(content)
                    outfile.write('\n\n')
            except Exception as e:
                # Обработка ошибок чтения файла
                outfile.write(f"⚠️ Ошибка чтения файла {filename}: {str(e)}\n\n")
                print(f"Ошибка: {e}")


if __name__ == "__main__":
    main()



==================== event_handler.py ====================

import pygame
from Happy_farm.src.game_state import GameState


class EventHandler:
    def __init__(self, game_manager):
        self.game_manager = game_manager

        # Области кнопок меню
        self.menu_buttons = {
            'play': pygame.Rect(0, 0, 200, 50),
            'settings': pygame.Rect(0, 0, 200, 50),
            'exit': pygame.Rect(0, 0, 200, 50)
        }

        # Области элементов настроек
        self.settings_elements = {
            'sound_slider': pygame.Rect(300, 150, 200, 20),
            'music_slider': pygame.Rect(300, 220, 200, 20),
            'fullscreen': pygame.Rect(300, 290, 20, 20),
            'fps_slider': pygame.Rect(300, 360, 200, 20),
            'back': pygame.Rect(0, 0, 200, 50)  # Кнопка "Назад"
        }

        self.dragging = None

    def update_button_positions(self, screen):
        """Обновление позиций кнопок меню"""
        screen_center_x = screen.get_width() // 2

        # Обновление позиций кнопок меню
        self.menu_buttons['play'].centerx = screen_center_x
        self.menu_buttons['play'].top = 250

        self.menu_buttons['settings'].centerx = screen_center_x
        self.menu_buttons['settings'].top = 320

        self.menu_buttons['exit'].centerx = screen_center_x
        self.menu_buttons['exit'].top = 390

        # Обновление позиции кнопки "Назад"
        self.settings_elements['back'].centerx = screen_center_x
        self.settings_elements['back'].bottom = screen.get_height() - 30

    def handle_events(self):
        """Обработка всех событий"""
        screen = self.game_manager.screen_manager.get_screen()
        self.update_button_positions(screen)

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return False

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    if self.game_manager.state == GameState.GAME:
                        self.game_manager.state = GameState.MENU

            if event.type == pygame.MOUSEBUTTONDOWN:
                if event.button == 1:  # Левая кнопка мыши
                    self.handle_mouse_down(event.pos)

            if event.type == pygame.MOUSEBUTTONUP:
                if event.button == 1:
                    self.handle_mouse_up(event.pos)

            if event.type == pygame.MOUSEMOTION:
                if self.dragging:
                    self.handle_mouse_motion(event.pos)

        return True

    def handle_mouse_down(self, pos):
        """Обработка нажатия кнопки мыши"""
        if self.game_manager.state == GameState.MENU:
            # Проверка кнопок меню
            if self.menu_buttons['play'].collidepoint(pos):
                self.game_manager.state = GameState.GAME
            elif self.menu_buttons['settings'].collidepoint(pos):
                self.game_manager.state = GameState.SETTINGS
            elif self.menu_buttons['exit'].collidepoint(pos):
                exit()

        elif self.game_manager.state == GameState.SETTINGS:
            # Проверка элементов настроек
            if self.settings_elements['back'].collidepoint(pos):
                self.game_manager.state = GameState.MENU
            elif self.settings_elements['sound_slider'].collidepoint(pos):
                self.dragging = 'sound'
                self.update_slider_value('sound', pos[0])
            elif self.settings_elements['music_slider'].collidepoint(pos):
                self.dragging = 'music'
                self.update_slider_value('music', pos[0])
            elif self.settings_elements['fps_slider'].collidepoint(pos):
                self.dragging = 'fps'
                self.update_slider_value('fps', pos[0])
            elif self.settings_elements['fullscreen'].collidepoint(pos):
                self.toggle_fullscreen()

        return True

    def handle_mouse_up(self, pos):
        """Обработка отпускания кнопки мыши"""
        self.dragging = None

    def handle_mouse_motion(self, pos):
        """Обработка движения мыши"""
        if self.dragging:
            self.update_slider_value(self.dragging, pos[0])

    def update_slider_value(self, slider_type, x_pos):
        """Обновление значения слайдера"""
        if slider_type in ['sound', 'music', 'fps']:
            slider_rect = self.settings_elements[f'{slider_type}_slider']
            relative_x = max(0, min(1, (x_pos - slider_rect.x) / slider_rect.width))

            if slider_type == 'sound':
                self.game_manager.settings['sound_volume'] = relative_x
            elif slider_type == 'music':
                self.game_manager.settings['music_volume'] = relative_x
            elif slider_type == 'fps':
                self.game_manager.settings['fps_limit'] = int(relative_x * 120) + 30  # 30-150 FPS

    def toggle_fullscreen(self):
        """Переключение полноэкранного режима"""
        self.game_manager.settings['fullscreen'] = not self.game_manager.settings['fullscreen']
        self.game_manager.toggle_fullscreen()



==================== game_manager.py ====================

import pygame
from Happy_farm.src.game_state import GameState
from Happy_farm.src.screen_manager import ScreenManager
from Happy_farm.src.event_handler import EventHandler
from Happy_farm.src.render_manager import RenderManager
from Happy_farm.src.player import Player
from Happy_farm.src.camera import Camera
import pytmx
import os


class GameManager:
    def __init__(self):
        pygame.init()
        pygame.font.init()

        self.screen_manager = ScreenManager()
        self.event_handler = EventHandler(self)
        self.render_manager = RenderManager(self.screen_manager)

        self.state = GameState.MENU
        self.running = True
        self.paused = False
        self.clock = pygame.time.Clock()

        self.settings = {
            'sound_volume': 0.7,
            'music_volume': 0.5,
            'fullscreen': False,
            'fps_limit': 60,
            'vsync': True,
            'language': 'en',
            'controls': {
                'up': pygame.K_w,
                'down': pygame.K_s,
                'left': pygame.K_a,
                'right': pygame.K_d,
                'interact': pygame.K_e,
                'inventory': pygame.K_i,
                'menu': pygame.K_ESCAPE
            }
        }

        self.fonts = {
            'small': pygame.font.Font(None, 24),
            'medium': pygame.font.Font(None, 36),
            'large': pygame.font.Font(None, 48)
        }

        #self.tools = {
        #    'hoe': Tool('Мотыга', pygame.image.load('sprites/tools/hoe.png'), 'hoe'),
        #    'axe': Tool('Топор', pygame.image.load('sprites/tools/axe.png'), 'axe'),
        #    'wateringcan': Tool('Лейка', pygame.image.load('sprites/tools/wateringcan.png'), 'wateringcan')
        #}

        self.inventory_open = False
        self.selected_item_index = 0
        self.hotbar_slots = [None] * 8
        self.inventory = [[None for _ in range(3)] for _ in range(8)]

        self.all_sprites = pygame.sprite.Group()
        self.players = pygame.sprite.Group()
        self.npcs = pygame.sprite.Group()
        self.obstacles = pygame.sprite.Group()
        self.items = pygame.sprite.Group()

        self.map_loaded = False
        try:
            self.tmx_data = pytmx.load_pygame('maps/maps.tmx')
            self.map_loaded = True
            print("Карта успешно загружена")
        except Exception as e:
            print(f"Ошибка загрузки карты: {e}")
            self.map_loaded = False

        screen = self.screen_manager.get_screen()
        self.camera = Camera(screen.get_width(), screen.get_height())
        print(f"Камера создана с размерами {screen.get_width()}x{screen.get_height()}")

        if self.map_loaded and hasattr(self, 'tmx_data'):
            map_width = self.tmx_data.width * self.tmx_data.tilewidth
            map_height = self.tmx_data.height * self.tmx_data.tileheight
            self.camera.set_map_size(map_width, map_height)
            print(f"Размеры карты для камеры установлены: {map_width}x{map_height}")

        self.init_game_objects()

        self.fps = 0
        self.frame_times = []
        self.last_update_time = pygame.time.get_ticks()

        print("GameManager инициализирован успешно")

    def handle_events(self):
        if not self.event_handler.handle_events():
            self.running = False
            return False

        keys = pygame.key.get_pressed()

        for i in range(8):
            if keys[getattr(pygame, f'K_{i + 1}')]:
                self.selected_item_index = i

        if keys[pygame.K_t]:
            self.inventory_open = not self.inventory_open

        return True

    def init_game_objects(self):
        spawn_point = self.get_spawn_point()
        if spawn_point:
            start_x, start_y = spawn_point
        else:
            screen = self.screen_manager.get_screen()
            start_x = screen.get_width() // 2
            start_y = screen.get_height() // 2

        self.player = Player(self, start_x, start_y)
        self.all_sprites.add(self.player)
        self.players.add(self.player)
        print(f"Игрок создан на позиции ({start_x}, {start_y})")

    def update(self):
        """Обновляет состояние игры"""
        delta_time = self.clock.tick(self.settings['fps_limit']) / 1000.0

        if self.state == GameState.GAME and not self.paused:
            # Сначала обновляем спрайты
            self.all_sprites.update(delta_time)

            # Обновляем камеру, привязывая её к игроку
            self.camera.update(self.player)

            # Отображение производительности (FPS)
            self.frame_times.append(delta_time)
            if len(self.frame_times) > 100:
                self.frame_times.pop(0)

            # Обновляем FPS каждые 500 мс
            current_time = pygame.time.get_ticks()
            if current_time - self.last_update_time > 500:
                if self.frame_times:
                    self.fps = int(1.0 / (sum(self.frame_times) / len(self.frame_times)))
                self.last_update_time = current_time

    def draw(self):
        """Отрисовка текущего состояния игры"""
        screen = self.screen_manager.get_screen()

        if self.state == GameState.MENU:
            self.render_manager.draw_menu(self)
        elif self.state == GameState.SETTINGS:
            self.render_manager.draw_settings(self)
        elif self.state == GameState.GAME:
            # Очистка экрана
            screen.fill((50, 50, 50))  # Серый фон, чтобы видеть, что экран очищается

            # Отрисовка карты
            if self.map_loaded:
                # Отрисовка каждого слоя карты
                for layer in self.tmx_data.visible_layers:
                    if hasattr(layer, 'data'):  # Если это слой тайлов
                        for x in range(layer.width):
                            for y in range(layer.height):
                                tile = layer.data[y][x]
                                if tile:
                                    # Получаем изображение тайла
                                    tile_image = self.tmx_data.get_tile_image_by_gid(tile)
                                    if tile_image:
                                        # Применяем смещение камеры к координатам тайла
                                        pos = self.camera.apply_rect(pygame.Rect(
                                            x * self.tmx_data.tilewidth,
                                            y * self.tmx_data.tileheight,
                                            self.tmx_data.tilewidth,
                                            self.tmx_data.tileheight
                                        ))
                                        screen.blit(tile_image, pos)

            # Отрисовка всех спрайтов
            for sprite in self.all_sprites:
                pos = self.camera.apply(sprite)
                screen.blit(sprite.image, pos.topleft)

            # Отрисовка интерфейса (не зависит от камеры)
            self.draw_inventory_and_hotbar(screen)

            # Отрисовка FPS (для отладки)
            fps_text = self.fonts['small'].render(f"FPS: {self.fps}", True, (255, 255, 255))
            screen.blit(fps_text, (10, 10))

        # Обновление экрана
        pygame.display.flip()

    def draw_inventory_and_hotbar(self, screen):
        panel_width = len(self.hotbar_slots) * 60 + 20
        panel_height = 70
        panel_x = (screen.get_width() - panel_width) // 2
        panel_y = screen.get_height() - panel_height - 10

        pygame.draw.rect(screen, (50, 50, 50), (panel_x, panel_y, panel_width, panel_height))

        for index, item in enumerate(self.hotbar_slots):
            slot_x = panel_x + 10 + index * 60
            slot_y = panel_y + 10

            if index == self.selected_item_index:
                pygame.draw.rect(screen, (255, 215, 0), (slot_x - 5, slot_y - 5, 50 + 10, 50 + 10), 3)

            pygame.draw.rect(screen, (100, 100, 100), (slot_x, slot_y, 50, 50))

            if item:
                item_surface = pygame.Surface((40, 40))
                item_surface.fill((0, 255, 0))
                screen.blit(item_surface, (slot_x + 5, slot_y + 5))

        if self.inventory_open:
            inventory_width = 3 * 70 + 20
            inventory_height = 8 * 70 + 20
            inventory_x = (screen.get_width() - inventory_width) // 2
            inventory_y = (screen.get_height() - inventory_height) // 2

            pygame.draw.rect(screen, (50, 50, 50), (inventory_x, inventory_y, inventory_width, inventory_height))

            for row in range(8):
                for col in range(3):
                    slot_x = inventory_x + 10 + col * 70
                    slot_y = inventory_y + 10 + row * 70

                    pygame.draw.rect(screen, (100, 100, 100), (slot_x, slot_y, 60, 60))

                    if self.inventory[row][col]:
                        item_surface = pygame.Surface((40, 40))
                        item_surface.fill((0, 0, 255))
                        screen.blit(item_surface, (slot_x + 10, slot_y + 10))

    def render_map(self, screen):
        """Отрисовка карты"""
        if not self.map_loaded:
            return

        # Получаем смещение камеры
        camera_offset = self.camera.offset

        # Размер тайла
        tile_width = self.tmx_data.tilewidth
        tile_height = self.tmx_data.tileheight

        # Вычисляем видимую область в тайлах
        start_x = int(camera_offset.x) // tile_width
        end_x = start_x + (screen.get_width() // tile_width) + 2
        start_y = int(camera_offset.y) // tile_height
        end_y = start_y + (screen.get_height() // tile_height) + 2

        # Ограничиваем индексы границами карты
        start_x = max(0, start_x)
        start_y = max(0, start_y)
        end_x = min(self.tmx_data.width, end_x)
        end_y = min(self.tmx_data.height, end_y)

        # Отрисовка видимых тайлов
        for layer in self.tmx_data.visible_layers:
            if hasattr(layer, 'data'):
                for y in range(start_y, end_y):
                    for x in range(start_x, end_x):
                        tile = layer.data[y][x]
                        if tile:
                            # Получаем изображение тайла
                            tile_image = self.tmx_data.get_tile_image_by_gid(tile)
                            if tile_image:
                                # Вычисляем позицию на экране
                                screen_x = x * tile_width - int(camera_offset.x)
                                screen_y = y * tile_height - int(camera_offset.y)
                                screen.blit(tile_image, (screen_x, screen_y))

    def toggle_fullscreen(self):
        self.settings['fullscreen'] = not self.settings['fullscreen']
        self.screen_manager.toggle_screen_mode('fullscreen')

        screen = self.screen_manager.get_screen()
        self.camera = Camera(screen.get_width(), screen.get_height())

        if self.map_loaded and hasattr(self, 'tmx_data'):
            map_width = self.tmx_data.width * self.tmx_data.tilewidth
            map_height = self.tmx_data.height * self.tmx_data.tileheight
            self.camera.set_map_size(map_width, map_height)

        print(f"Переключен режим экрана, новые размеры: {screen.get_width()}x{screen.get_height()}")

    def set_sound_volume(self, volume):
        self.settings['sound_volume'] = max(0.0, min(1.0, volume))
        print(f"Установлена громкость звука: {volume}")

    def set_music_volume(self, volume):
        self.settings['music_volume'] = max(0.0, min(1.0, volume))
        print(f"Установлена громкость музыки: {volume}")

    def save_settings(self):
        print("Настройки сохранены")

    def load_settings(self):
        print("Настройки загружены")

    def run(self):
        self.load_settings()

        while self.running:
            self.handle_events()
            self.update()
            self.draw()

        self.save_settings()
        pygame.quit()

    def get_spawn_point(self):
        if self.map_loaded:
            for layer in self.tmx_data.layers:
                if hasattr(layer, 'objects'):
                    for obj in layer:
                        if hasattr(obj, 'type') and (obj.type == 'spawn' or obj.name == 'player_spawn'):
                            return obj.x, obj.y
        return None

    def reset_game(self):
        self.all_sprites.empty()
        self.players.empty()
        self.npcs.empty()
        self.obstacles.empty()
        self.items.empty()

        self.init_game_objects()
        self.state = GameState.MENU
        self.paused = False

        print("Игра сброшена в начальное состояние")



==================== game_state.py ====================

from enum import Enum

class GameState(Enum):
    MENU = 0
    SETTINGS = 1
    GAME = 2
    PAUSE = 3  # Добавим еще и состояние паузы



==================== item.py ====================

import pygame


class Item(pygame.sprite.Sprite):
    def __init__(self, name, image, tool_type):
        super().__init__()
        self.name = name
        self.image = image
        self.rect = self.image.get_rect()
        self.tool_type = tool_type  # hoe, axe, wateringcan

    def use(self, target):
        pass  # Реализуем в подклассах


class Tool(Item):
    def __init__(self, name, image, tool_type, durability=100):
        super().__init__(name, image, tool_type)
        self.durability = durability
        self.max_durability = durability



==================== map_renderer.py ====================

import pygame
from Happy_farm.src.tilemap import TiledMap


class MapRenderer:
    def __init__(self):
        self.tilemap = None

    def load_map(self, map_path):
        """Загрузка карты"""
        try:
            self.tilemap = TiledMap(map_path)
            return True
        except Exception as e:
            print(f"Ошибка загрузки карты: {e}")
            return False

    def draw_map(self, screen, camera):
        """Отрисовка карты с учетом камеры"""
        if self.tilemap:
            screen.fill((0, 0, 0))  # Очистка экрана
            self.tilemap.draw(screen, camera)



==================== player.py ====================

import pygame
import pytmx
import os


class Player(pygame.sprite.Sprite):
    def __init__(self, game_manager, x, y, speed=100):
        super().__init__()
        self.game = game_manager

        # Пути к спрайтам
        self.sprite_path = "sprites/player/sprites"

        # Загрузка и организация спрайтов
        self.animations = self.load_animations()

        # Начальное положение и скорость
        self.x = float(x)
        self.y = float(y)
        self.speed = speed

        # Анимационные переменные
        self.direction = "down"  # Начальное направление
        self.moving = False
        self.current_frame = 0
        self.animation_speed = 8  # Кадров в секунду
        self.animation_timer = 0

        # Установка начального изображения и прямоугольника
        self.image = self.animations[self.direction][0]
        self.rect = self.image.get_rect(topleft=(x, y))

        # Создаем отдельный прямоугольник для коллизий
        self.collision_rect = pygame.Rect(0, 0, 16, 16)  # Размер коллизии (16x16)
        self.update_collision_rect()  # Обновляем позицию коллизии

        print(f"Игрок создан на позиции ({x}, {y}) со скоростью {speed}")

    def load_animations(self):
        """Загрузка всех анимаций игрока"""
        animations = {
            "down": [],
            "left": [],
            "right": [],
            "up": [],
        }

        # Проверяем наличие папки со спрайтами
        if not os.path.exists(self.sprite_path):
            print(f"Ошибка: Путь {self.sprite_path} не существует.")
            # Создаем заглушку - зеленый квадрат
            dummy = pygame.Surface((16, 16))
            dummy.fill((0, 255, 0))
            for direction in animations:
                animations[direction] = [dummy]
            return animations

        try:
            # Сопоставляем индексы с направлениями
            directions_map = {
                "down": [0, 1, 2, 3],  # первая строка (индексы 0-3)
                "left": [8, 9, 10, 11],  # вторая строка (индексы 4-7)
                "right": [12, 13, 14, 15],  # третья строка (индексы 8-11)
                "up": [4, 5, 6, 7],  # четвертая строка (индексы 12-15)
            }

            # Загружаем все спрайты
            sprites = []
            for i in range(16):  # 16 спрайтов (4x4)
                img_path = os.path.join(self.sprite_path, f"sprite_{i}.png")
                if os.path.exists(img_path):
                    sprite = pygame.image.load(img_path).convert_alpha()
                    # Масштабируем спрайт, если нужно
                    sprite = pygame.transform.scale(sprite, (70, 92))
                    sprites.append(sprite)
                else:
                    print(f"Предупреждение: Файл {img_path} не найден.")
                    dummy = pygame.Surface((16, 16))
                    dummy.fill((255, 0, 255))  # Фиолетовый для обозначения отсутствия
                    sprites.append(dummy)

            # Распределяем спрайты по анимациям
            for direction, indices in directions_map.items():
                for idx in indices:
                    if idx < len(sprites):
                        animations[direction].append(sprites[idx])

        except Exception as e:
            print(f"Ошибка при загрузке спрайтов: {e}")
            # Создаем заглушку в случае ошибки
            dummy = pygame.Surface((32, 32))
            dummy.fill((0, 255, 0))
            for direction in animations:
                animations[direction] = [dummy]

        return animations

    def update(self, dt):
        """Обновление игрока"""
        keys = pygame.key.get_pressed()

        # Сохраняем предыдущее положение для проверки коллизий
        prev_x = self.x
        prev_y = self.y

        # Сбрасываем флаг движения
        was_moving = self.moving
        self.moving = False

        # Рассчитываем новое положение
        dx = 0
        dy = 0

        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            dx = -self.speed * dt
            self.direction = "left"
            self.moving = True
        elif keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            dx = self.speed * dt
            self.direction = "right"
            self.moving = True

        if keys[pygame.K_UP] or keys[pygame.K_w]:
            dy = -self.speed * dt
            self.direction = "up"
            self.moving = True
        elif keys[pygame.K_DOWN] or keys[pygame.K_s]:
            dy = self.speed * dt
            self.direction = "down"
            self.moving = True

        # Обновляем позиции отдельно, чтобы проверить коллизии
        # Обновляем X
        self.x += dx
        self.rect.x = int(self.x)
        self.update_collision_rect()  # Обновляем позицию прямоугольника коллизии
        if self.check_collision():
            self.x = prev_x
            self.rect.x = int(prev_x)

        # Обновляем Y
        self.y += dy
        self.rect.y = int(self.y)
        self.update_collision_rect()  # Обновляем позицию прямоугольника коллизии
        if self.check_collision():
            self.y = prev_y
            self.rect.y = int(prev_y)

        # Ограничение движения игрока границами карты
        if hasattr(self.game, "tmx_data") and self.game.map_loaded:
            map_width = self.game.tmx_data.width * self.game.tmx_data.tilewidth
            map_height = self.game.tmx_data.height * self.game.tmx_data.tileheight
            self.x = max(0, min(self.x, map_width - self.rect.width))
            self.y = max(0, min(self.y, map_height - self.rect.height))
            self.rect.x = int(self.x)
            self.rect.y = int(self.y)

        # Обновление анимации
        self.update_animation(dt, was_moving)

    def update_collision_rect(self):
        """Обновляет позицию прямоугольника коллизии."""
        self.collision_rect.center = self.rect.center

    def update_animation(self, dt, was_moving):
        """Обновление анимации игрока"""
        # Если начали или прекратили движение, сбрасываем кадр и таймер
        if was_moving != self.moving:
            self.current_frame = 0
            self.animation_timer = 0

        if self.moving:
            # Обновляем таймер анимации
            self.animation_timer += dt
            # Если прошло достаточно времени, переходим к следующему кадру
            if self.animation_timer >= 1.0 / self.animation_speed:
                self.animation_timer = 0
                # Переключаемся на следующий кадр
                self.current_frame = (self.current_frame + 1) % len(self.animations[self.direction])
        else:
            # Если не движемся, используем первый кадр
            self.current_frame = 0

        # Обновляем текущее изображение
        self.image = self.animations[self.direction][self.current_frame]

    def check_collision(self):
        """Проверка коллизий игрока с объектами на карте."""
        if not hasattr(self.game, "tmx_data") or not self.game.map_loaded:
            return False

        for layer in self.game.tmx_data.layers:
            if layer.name == "Коллизия лес" and isinstance(layer, pytmx.TiledTileLayer):
                for x, y, gid in layer:
                    if gid != 0:
                        tile_rect = pygame.Rect(
                            x * self.game.tmx_data.tilewidth,
                            y * self.game.tmx_data.tileheight,
                            self.game.tmx_data.tilewidth,
                            self.game.tmx_data.tileheight,
                        )
                        if self.collision_rect.colliderect(tile_rect):
                            return True
            if layer.name == "Колилзия горок" and isinstance(layer, pytmx.TiledTileLayer):
                for x, y, gid in layer:
                    if gid != 0:
                        tile_rect = pygame.Rect(
                            x * self.game.tmx_data.tilewidth,
                            y * self.game.tmx_data.tileheight,
                            self.game.tmx_data.tilewidth,
                            self.game.tmx_data.tileheight,
                        )
                        if self.collision_rect.colliderect(tile_rect):
                            return True
            if layer.name == "Коллизия река и Озеро" and isinstance(layer, pytmx.TiledTileLayer):
                for x, y, gid in layer:
                    if gid != 0:
                        tile_rect = pygame.Rect(
                            x * self.game.tmx_data.tilewidth,
                            y * self.game.tmx_data.tileheight,
                            self.game.tmx_data.tilewidth,
                            self.game.tmx_data.tileheight,
                        )
                        if self.collision_rect.colliderect(tile_rect):
                            return True
            if layer.name == "Коллизия камней" and isinstance(layer, pytmx.TiledTileLayer):
                for x, y, gid in layer:
                    if gid != 0:
                        tile_rect = pygame.Rect(
                            x * self.game.tmx_data.tilewidth,
                            y * self.game.tmx_data.tileheight,
                            self.game.tmx_data.tilewidth,
                            self.game.tmx_data.tileheight,
                        )
                        if self.collision_rect.colliderect(tile_rect):
                            return True
            if layer.name == "Дом" and isinstance(layer, pytmx.TiledTileLayer):
                for x, y, gid in layer:
                    if gid != 0:
                        tile_rect = pygame.Rect(
                            x * self.game.tmx_data.tilewidth,
                            y * self.game.tmx_data.tileheight,
                            self.game.tmx_data.tilewidth,
                            self.game.tmx_data.tileheight,
                        )
                        if self.collision_rect.colliderect(tile_rect):
                            return True
            if layer.name == "Коллизия Мосты" and isinstance(layer, pytmx.TiledTileLayer):
                for x, y, gid in layer:
                    if gid != 0:
                        tile_rect = pygame.Rect(
                            x * self.game.tmx_data.tilewidth,
                            y * self.game.tmx_data.tileheight,
                            self.game.tmx_data.tilewidth,
                            self.game.tmx_data.tileheight,
                        )
                        if self.collision_rect.colliderect(tile_rect):
                            return True
        return False


==================== render_manager.py ====================

import pygame
from Happy_farm.src.map_renderer import MapRenderer

class RenderManager:
    def __init__(self, screen_manager):
        self.screen_manager = screen_manager
        self.map_renderer = MapRenderer()

        # Инициализация шрифтов
        self.title_font = pygame.font.Font(None, 64)
        self.menu_font = pygame.font.Font(None, 36)
        self.ui_font = pygame.font.Font(None, 24)

        # Цветовая палитра
        self.COLORS = {
            'WHITE': (255, 255, 255),
            'BLACK': (0, 0, 0),
            'GRAY': (128, 128, 128),
            'LIGHT_GRAY': (192, 192, 192),
            'GREEN': (0, 255, 0),
            'RED': (255, 0, 0),
            'BLUE': (0, 0, 255),
            'TRANSPARENT_BLACK': (0, 0, 0, 128)
        }

        # Размеры кнопок и отступы
        self.BUTTON_SIZE = (200, 50)
        self.BUTTON_SPACING = 20
        self.SLIDER_SIZE = (200, 20)
        self.CHECKBOX_SIZE = (20, 20)

    def draw_menu(self, game_manager):
        """Отрисовка главного меню"""
        screen = self.screen_manager.get_screen()
        screen.fill(self.COLORS['BLACK'])

        # Заголовок
        title = self.title_font.render("Happy Farm", True, self.COLORS['WHITE'])
        title_rect = title.get_rect(center=(screen.get_width() // 2, 100))
        screen.blit(title, title_rect)

        # Кнопки меню
        buttons = ["Начать игру", "Настройки", "Выход"]
        button_y = 250

        for text in buttons:
            button_rect = pygame.Rect(
                (screen.get_width() - self.BUTTON_SIZE[0]) // 2,
                button_y,
                self.BUTTON_SIZE[0],
                self.BUTTON_SIZE[1]
            )

            # Проверка наведения мыши
            mouse_pos = pygame.mouse.get_pos()
            if button_rect.collidepoint(mouse_pos):
                pygame.draw.rect(screen, self.COLORS['GRAY'], button_rect)
                color = self.COLORS['WHITE']
            else:
                pygame.draw.rect(screen, self.COLORS['WHITE'], button_rect, 2)
                color = self.COLORS['WHITE']

            # Текст кнопки
            text_surface = self.menu_font.render(text, True, color)
            text_rect = text_surface.get_rect(center=button_rect.center)
            screen.blit(text_surface, text_rect)

            button_y += self.BUTTON_SIZE[1] + self.BUTTON_SPACING

    def draw_settings(self, game_manager):
        """Отрисовка меню настроек"""
        screen = self.screen_manager.get_screen()
        screen.fill(self.COLORS['BLACK'])

        # Заголовок
        title = self.title_font.render("Настройки", True, self.COLORS['WHITE'])
        title_rect = title.get_rect(center=(screen.get_width() // 2, 50))
        screen.blit(title, title_rect)

        # Настройки звука
        self.draw_slider(screen, "Громкость звука", game_manager.settings['sound_volume'], 150)
        self.draw_slider(screen, "Громкость музыки", game_manager.settings['music_volume'], 220)

        # Настройки экрана
        self.draw_checkbox(screen, "Полный экран", game_manager.settings['fullscreen'], 290)

        # Настройки FPS
        self.draw_slider(screen, "Ограничение FPS", game_manager.settings['fps_limit'] / 120, 360)

        # Кнопка "Назад"
        back_rect = pygame.Rect(
            (screen.get_width() - self.BUTTON_SIZE[0]) // 2,
            screen.get_height() - 80,
            self.BUTTON_SIZE[0],
            self.BUTTON_SIZE[1]
        )

        mouse_pos = pygame.mouse.get_pos()
        if back_rect.collidepoint(mouse_pos):
            pygame.draw.rect(screen, self.COLORS['GRAY'], back_rect)
            color = self.COLORS['WHITE']
        else:
            pygame.draw.rect(screen, self.COLORS['WHITE'], back_rect, 2)
            color = self.COLORS['WHITE']

        back_text = self.menu_font.render("Назад", True, color)
        back_text_rect = back_text.get_rect(center=back_rect.center)
        screen.blit(back_text, back_text_rect)

    def draw_game(self, screen, game_manager):
        """Отрисовка игрового экрана"""
        screen.fill((0, 0, 0))  # Заливка экрана черным цветом

        # Отрисовка карты с учетом камеры
        if game_manager.map_loaded:
            # Получаем видимую область
            camera_rect = game_manager.camera.camera

            # Отрисовываем видимые тайлы
            for layer in game_manager.tmx_data.visible_layers:
                if hasattr(layer, 'data'):
                    # Определяем видимую область в тайлах
                    startx = max(0, camera_rect.x // game_manager.tmx_data.tilewidth)
                    starty = max(0, camera_rect.y // game_manager.tmx_data.tileheight)
                    endx = min(game_manager.tmx_data.width,
                               (camera_rect.x + camera_rect.width) // game_manager.tmx_data.tilewidth + 1)
                    endy = min(game_manager.tmx_data.height,
                               (camera_rect.y + camera_rect.height) // game_manager.tmx_data.tileheight + 1)

                    # Отрисовываем только видимые тайлы
                    for x in range(startx, endx):
                        for y in range(starty, endy):
                            gid = layer.data[y][x]
                            if gid:
                                tile = game_manager.tmx_data.get_tile_image_by_gid(gid)
                                if tile:
                                    # Применяем смещение камеры
                                    pos = game_manager.camera.apply_point(
                                        x * game_manager.tmx_data.tilewidth,
                                        y * game_manager.tmx_data.tileheight
                                    )
                                    screen.blit(tile, pos)

        # Отрисовка спрайтов с учетом камеры
        for sprite in game_manager.all_sprites:
            # Применяем камеру к позиции спрайта
            camera_rect = game_manager.camera.apply(sprite)
            screen.blit(sprite.image, camera_rect)

            # Если это игрок, рисуем его имя
            if sprite == game_manager.player:
                # Отрисовка таблички с именем игрока
                name_tag_bg_rect = pygame.Rect(
                    camera_rect.centerx - sprite.name_tag_bg.get_width() // 2,
                    camera_rect.top - sprite.name_tag_bg.get_height() - 5,
                    sprite.name_tag_bg.get_width(),
                    sprite.name_tag_bg.get_height()
                )
                screen.blit(sprite.name_tag_bg, name_tag_bg_rect)

                name_tag_rect = pygame.Rect(
                    camera_rect.centerx - sprite.name_tag.get_width() // 2,
                    camera_rect.top - sprite.name_tag.get_height() - 7,
                    sprite.name_tag.get_width(),
                    sprite.name_tag.get_height()
                )
                screen.blit(sprite.name_tag, name_tag_rect)

    def draw_map(self, screen, game_manager):
        """Отрисовка игровой карты"""
        for layer in game_manager.tmx_data.visible_layers:
            if hasattr(layer, 'data'):
                for x, y, gid in layer:
                    tile = game_manager.tmx_data.get_tile_image_by_gid(gid)
                    if tile:
                        screen.blit(tile, (x * game_manager.tmx_data.tilewidth,
                                           y * game_manager.tmx_data.tileheight))

    def draw_game_ui(self, screen, game_manager):
        """Отрисовка игрового интерфейса"""
        # Отображение FPS
        fps = str(int(game_manager.clock.get_fps()))
        fps_text = self.ui_font.render(f"FPS: {fps}", True, self.COLORS['WHITE'])
        screen.blit(fps_text, (10, 10))

    def draw_slider(self, screen, text, value, y_pos):
        """Отрисовка слайдера настроек"""
        # Текст настройки
        text_surface = self.menu_font.render(text, True, self.COLORS['WHITE'])
        screen.blit(text_surface, (50, y_pos))

        # Слайдер
        slider_rect = pygame.Rect(300, y_pos, self.SLIDER_SIZE[0], self.SLIDER_SIZE[1])
        pygame.draw.rect(screen, self.COLORS['WHITE'], slider_rect, 2)

        # Заполнение слайдера
        fill_rect = pygame.Rect(301, y_pos + 1, (self.SLIDER_SIZE[0] - 2) * value, self.SLIDER_SIZE[1] - 2)
        pygame.draw.rect(screen, self.COLORS['WHITE'], fill_rect)

        # Значение
        value_text = self.menu_font.render(f"{int(value * 100)}%", True, self.COLORS['WHITE'])
        screen.blit(value_text, (520, y_pos))

    def draw_checkbox(self, screen, text, checked, y_pos):
        """Отрисовка чекбокса настроек"""
        # Текст настройки
        text_surface = self.menu_font.render(text, True, self.COLORS['WHITE'])
        screen.blit(text_surface, (50, y_pos))

        # Чекбокс
        checkbox_rect = pygame.Rect(300, y_pos, self.CHECKBOX_SIZE[0], self.CHECKBOX_SIZE[1])
        pygame.draw.rect(screen, self.COLORS['WHITE'], checkbox_rect, 2)

        # Отметка
        if checked:
            inner_rect = pygame.Rect(
                checkbox_rect.x + 4,
                checkbox_rect.y + 4,
                checkbox_rect.width - 8,
                checkbox_rect.height - 8
            )
            pygame.draw.rect(screen, self.COLORS['WHITE'], inner_rect)

    def draw_loading_screen(self, screen, progress=0):
        """Отрисовка экрана загрузки"""
        screen.fill(self.COLORS['BLACK'])

        # Текст загрузки
        loading_text = self.title_font.render("Загрузка...", True, self.COLORS['WHITE'])
        text_rect = loading_text.get_rect(center=(screen.get_width() // 2, screen.get_height() // 2 - 50))
        screen.blit(loading_text, text_rect)

        # Полоса загрузки
        bar_rect = pygame.Rect(
            screen.get_width() // 4,
            screen.get_height() // 2 + 20,
            screen.get_width() // 2,
            20
        )
        pygame.draw.rect(screen, self.COLORS['WHITE'], bar_rect, 2)

        # Заполнение полосы загрузки
        fill_rect = pygame.Rect(
            bar_rect.x + 2,
            bar_rect.y + 2,
            (bar_rect.width - 4) * progress,
            bar_rect.height - 4
        )
        pygame.draw.rect(screen, self.COLORS['WHITE'], fill_rect)

        pygame.display.flip()



==================== resource_loader.py ====================

import os
import pygame
import pytmx


class ResourceLoader:
    @staticmethod
    def load_resources():
        resources = {
            'loaded': False,
            'sprites': {},
            'sounds': {},
            'tilemap': None
        }

        try:
            # Проверяем, существуют ли необходимые файлы
            required_files = ["maps.tmx", "player_action_sprite_heet.png", "gra.tsx"]  # Добавили gra.tsx
            missing_files = [f for f in required_files if not os.path.exists(f)]

            if missing_files:
                print(f"Отсутствуют файлы: {', '.join(missing_files)}")
                return resources

            # Создаем проверку для grass.png, если она требуется
            if not os.path.exists("grass.png") and os.path.exists("gra.tsx"):
                print("Файл grass.png не найден, но найден gra.tsx. Используем его вместо grass.png")
                # Можно сделать симлинк или копию файла, если система ожидает определенное имя
                # Пример: os.symlink("gra.tsx", "grass.png")

            # Загрузка TMX карты с указанием базового пути к тайлсетам
            resources['tilemap'] = pytmx.load_pygame("maps.tmx", pixelalpha=True)

            # Загрузка спрайта игрока
            resources['sprites']['player'] = pygame.image.load("character_move_sprite_sheet.png").convert_alpha()

            resources['loaded'] = True
            return resources

        except Exception as e:
            print(f"Ошибка при загрузке ресурсов: {e}")
            return resources


==================== screen_manager.py ====================

import pygame
from Happy_farm.src.settings import WINDOW_SIZE
from Happy_farm.src.settings import FULLSCREEN_SIZE

class ScreenManager:
    def __init__(self):
        self.current_mode = 'windowed'
        self.screen = pygame.display.set_mode(WINDOW_SIZE[self.current_mode])
        pygame.display.set_caption("Happy Farm")

    def toggle_screen_mode(self, mode):
        if mode != self.current_mode:
            self.current_mode = mode
            if mode == 'fullscreen':
                self.screen = pygame.display.set_mode(WINDOW_SIZE[mode], pygame.FULLSCREEN)
            else:
                self.screen = pygame.display.set_mode(WINDOW_SIZE[mode])

    def get_screen(self):
        return self.screen

    def get_center_x(self):
        return WINDOW_SIZE[self.current_mode][0] // 2

    def get_center_y(self):
        return WINDOW_SIZE[self.current_mode][1] // 2

    def get_current_mode(self):
        return self.current_mode



==================== settings.py ====================

import pygame

# Инициализация pygame перед получением информации о дисплее
pygame.init()

# Константы для цветов
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GRAY = (128, 128, 128)
DARK_GRAY = (64, 64, 64)

# Базовое разрешение для оконного режима
DEFAULT_WINDOW_SIZE = (800, 600)

# Получаем размер экрана
screen_info = pygame.display.Info()
FULLSCREEN_SIZE = (screen_info.current_w, screen_info.current_h)

# Настройки экрана
WINDOW_SIZE = {
    'windowed': DEFAULT_WINDOW_SIZE,
    'fullscreen': FULLSCREEN_SIZE
}

# Настройки по умолчанию
settings = {
    'window_mode': 'windowed',  # 'windowed', 'borderless', 'fullscreen'
    'music_volume': 0.7,
    'sound_volume': 0.7,
    'master_volume': 0.7
}


==================== tilemap.py ====================

import pygame


class TiledMap:
    def __init__(self, tmx_data):
        self.tmx_data = tmx_data
        self.width = tmx_data.width * tmx_data.tilewidth
        self.height = tmx_data.height * tmx_data.tileheight
        self.render_surface = self.make_map()

    def render(self, surface, pos=(0, 0)):
        surface.blit(self.render_surface, pos)

    def make_map(self):
        temp_surface = pygame.Surface((self.width, self.height))
        temp_surface.set_colorkey((0, 0, 0))

        # Отрисовка каждого слоя
        for layer in self.tmx_data.visible_layers:
            if hasattr(layer, 'data'):  # Это слой тайлов
                for x, y, gid in layer:
                    tile = self.tmx_data.get_tile_image_by_gid(gid)
                    if tile:
                        temp_surface.blit(
                            tile,
                            (x * self.tmx_data.tilewidth,
                             y * self.tmx_data.tileheight)
                        )

        return temp_surface

    def get_tile_properties(self, x, y, layer):
        """Получение свойств тайла по координатам"""
        tile = self.tmx_data.get_tile_properties(x, y, layer)
        return tile if tile else None

    def get_object_layer(self, layer_name):
        """Получение слоя объектов по имени"""
        return self.tmx_data.get_layer_by_name(layer_name)



==================== ui.py ====================

import pygame
from settings import WHITE, BLACK, GRAY, DARK_GRAY


class Button:
    def __init__(self, x, y, width, height, text, font_size=32):
        self.rect = pygame.Rect(x, y, width, height)
        self.text = text
        self.font = pygame.font.Font(None, font_size)
        self.is_hovered = False

    def draw(self, surface):
        color = DARK_GRAY if self.is_hovered else GRAY
        pygame.draw.rect(surface, color, self.rect)
        pygame.draw.rect(surface, BLACK, self.rect, 2)

        text_surface = self.font.render(self.text, True, WHITE)
        text_rect = text_surface.get_rect(center=self.rect.center)
        surface.blit(text_surface, text_rect)

    def handle_event(self, event):
        if event.type == pygame.MOUSEMOTION:
            self.is_hovered = self.rect.collidepoint(event.pos)
        elif event.type == pygame.MOUSEBUTTONDOWN:
            if self.is_hovered:
                return True
        return False


class Slider:
    def __init__(self, x, y, width, height, start_value=0.7):
        self.rect = pygame.Rect(x, y, width, height)
        self.value = start_value
        self.grabbed = False

    def draw(self, surface):
        pygame.draw.rect(surface, GRAY, self.rect)
        pygame.draw.rect(surface, BLACK, self.rect, 2)

        slider_x = self.rect.x + (self.rect.width * self.value) - 5
        slider_rect = pygame.Rect(slider_x, self.rect.y - 5, 10, self.rect.height + 10)
        pygame.draw.rect(surface, WHITE, slider_rect)
        pygame.draw.rect(surface, BLACK, slider_rect, 2)

    def handle_event(self, event):
        if event.type == pygame.MOUSEBUTTONDOWN:
            if self.rect.collidepoint(event.pos):
                self.grabbed = True
        elif event.type == pygame.MOUSEBUTTONUP:
            self.grabbed = False
        elif event.type == pygame.MOUSEMOTION and self.grabbed:
            relative_x = event.pos[0] - self.rect.x
            self.value = max(0, min(1, relative_x / self.rect.width))
            return True
        return False



==================== __init__.py ====================

"""
Happy Farm Game Package
Version: 1.0.0
"""

# Константы игры
GAME_TITLE = "Happy Farm"
GAME_VERSION = "1.0.0"

# Размеры окна по умолчанию
DEFAULT_WINDOW_WIDTH = 800
DEFAULT_WINDOW_HEIGHT = 600

# Настройки игрока
PLAYER_SPEED = 200
PLAYER_SIZE = (32, 32)

# Настройки карты
TILE_SIZE = 32
MAP_LAYERS = {
    'ground': 0,
    'buildings': 1,
    'objects': 2,
    'overlay': 3
}

# Настройки игры по умолчанию
DEFAULT_SETTINGS = {
    'sound_volume': 0.7,
    'music_volume': 0.5,
    'fullscreen': False,
    'fps_limit': 60
}

# Пути к ресурсам
RESOURCE_PATHS = {
    'maps': 'maps',
    'sprites': 'sprites',
    'sounds': 'sounds',
    'music': 'music',
    'fonts': 'fonts'
}


