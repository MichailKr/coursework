
==================== camera.py ====================

import pygame
from pygame.math import Vector2

class Camera:
    def __init__(self, width, height):
        """
        Инициализация камеры
        Args:
            width (int): Ширина видимой области (экрана)
            height (int): Высота видимой области (экрана)
        """
        self.width = width
        self.height = height
        self.offset = Vector2(0, 0)
        self.map_width = 0
        self.map_height = 0
        print("Камера инициализирована")

    def set_map_size(self, width, height):
        """Установка размеров карты для ограничения движения камеры"""
        self.map_width = width
        self.map_height = height
        print(f"Установлены размеры карты для камеры: {width}x{height}")

    def apply(self, entity):
        """
        Применяет смещение камеры к позиции объекта
        Args:
            entity: Объект с атрибутом rect
        Returns:
            pygame.Rect: Новый прямоугольник с учетом смещения камеры
        """
        return pygame.Rect(
            entity.rect.x - int(self.offset.x),
            entity.rect.y - int(self.offset.y),
            entity.rect.width,
            entity.rect.height
        )

    def apply_rect(self, rect):
        """Применяет смещение камеры к прямоугольнику"""
        return pygame.Rect(
            rect.x - int(self.offset.x),
            rect.y - int(self.offset.y),
            rect.width,
            rect.height
        )

    def apply_point(self, x, y):
        """Применяет смещение камеры к точке"""
        return (x - int(self.offset.x), y - int(self.offset.y))

    def update(self, target):
        """
        Обновляет позицию камеры, чтобы следовать за целью
        Args:
            target: Объект, за которым следует камера (обычно игрок)
        """
        # Вычисляем желаемое смещение камеры
        self.offset.x = target.rect.centerx - self.width // 2
        self.offset.y = target.rect.centery - self.height // 2

        # Ограничиваем смещение камеры границами карты
        self.offset.x = max(0, min(self.offset.x, self.map_width - self.width))
        self.offset.y = max(0, min(self.offset.y, self.map_height - self.height))



==================== collect.py ====================

import glob


def main():
    with open('../output.txt', 'w', encoding='utf-8') as outfile:
        # Собираем все .php и .css файлы
        for filename in glob.glob('*.py'):
            # Записываем название файла
            outfile.write(f"\n{'=' * 20} {filename} {'=' * 20}\n\n")

            try:
                # Читаем содержимое файла
                with open(filename, 'r', encoding='utf-8') as infile:
                    content = infile.read()
                    # Записываем содержимое в выходной файл
                    outfile.write(content)
                    outfile.write('\n\n')
            except Exception as e:
                # Обработка ошибок чтения файла
                outfile.write(f"⚠️ Ошибка чтения файла {filename}: {str(e)}\n\n")
                print(f"Ошибка: {e}")


if __name__ == "__main__":
    main()



==================== event_handler.py ====================

import pygame

from src.game_state import GameState

class EventHandler:
    def __init__(self, game_manager):
        self.game_manager = game_manager

        # Области кнопок меню
        self.menu_buttons = {
            'play': pygame.Rect(0, 0, 200, 50),
            'settings': pygame.Rect(0, 0, 200, 50),
            'exit': pygame.Rect(0, 0, 200, 50)
        }

        # Области элементов настроек
        self.settings_elements = {
            'sound_slider': pygame.Rect(300, 150, 200, 20),
            'music_slider': pygame.Rect(300, 220, 200, 20),
            'fullscreen': pygame.Rect(300, 290, 20, 20),
            'fps_slider': pygame.Rect(300, 360, 200, 20),
            'back': pygame.Rect(0, 0, 200, 50)  # Кнопка "Назад"
        }
        self.dragging = None

    def update_button_positions(self, screen):
        """Обновление позиций кнопок меню"""
        screen_center_x = screen.get_width() // 2
        # Обновление позиций кнопок меню
        self.menu_buttons['play'].centerx = screen_center_x
        self.menu_buttons['play'].top = 250
        self.menu_buttons['settings'].centerx = screen_center_x
        self.menu_buttons['settings'].top = 320
        self.menu_buttons['exit'].centerx = screen_center_x
        self.menu_buttons['exit'].top = 390
        # Обновление позиции кнопки "Назад"
        self.settings_elements['back'].centerx = screen_center_x
        self.settings_elements['back'].bottom = screen.get_height() - 30

    # --- Измените метод handle_events ---
    # Теперь этот метод принимает одно событие за раз
    def handle_events(self, event): # Добавлен аргумент 'event'
        """Обработка одного события Pygame."""
        screen = self.game_manager.screen_manager.get_screen()
        self.update_button_positions(screen) # Возможно, обновление позиций лучше делать в другом месте, но пока оставим здесь

        # --- Удалите цикл for event in pygame.event.get(): ---
        # События теперь получаются и передаются из GameManager

        if event.type == pygame.QUIT:
            return False # Сигнализируем GameManager о выходе из игры

        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                if self.game_manager.state == GameState.GAME:
                    self.game_manager.state = GameState.MENU
            # TODO: Добавьте здесь обработку других клавиш, не связанных с инвентарем (например, движение игрока)
            # if event.key == self.game_manager.settings['controls']['up']:
            #      self.game_manager.player.move(0, -1)
            # ... другие клавиши движения ...


        if event.type == pygame.MOUSEBUTTONDOWN:
            if event.button == 1:  # Левая кнопка мыши
                self.handle_mouse_down(event.pos)

        if event.type == pygame.MOUSEBUTTONUP:
            if event.button == 1:
                self.handle_mouse_up(event.pos)

        if event.type == pygame.MOUSEMOTION:
            if self.dragging:
                self.handle_mouse_motion(event.pos)

        return True # Продолжаем игру
    # --- Конец изменения ---

    def handle_mouse_down(self, pos):
        """Обработка нажатия кнопки мыши"""
        if self.game_manager.state == GameState.MENU:
            # Проверка кнопок меню
            if self.menu_buttons['play'].collidepoint(pos):
                self.game_manager.state = GameState.GAME
            elif self.menu_buttons['settings'].collidepoint(pos):
                self.game_manager.state = GameState.SETTINGS
            elif self.menu_buttons['exit'].collidepoint(pos):
                exit()

        elif self.game_manager.state == GameState.SETTINGS:
            # Проверка элементов настроек
            if self.settings_elements['back'].collidepoint(pos):
                self.game_manager.state = GameState.MENU
            elif self.settings_elements['sound_slider'].collidepoint(pos):
                self.dragging = 'sound'
                self.update_slider_value('sound', pos[0])
            elif self.settings_elements['music_slider'].collidepoint(pos):
                self.dragging = 'music'
                self.update_slider_value('music', pos[0])
            elif self.settings_elements['fps_slider'].collidepoint(pos):
                self.dragging = 'fps'
                self.update_slider_value('fps', pos[0])
            elif self.settings_elements['fullscreen'].collidepoint(pos):
                self.toggle_fullscreen()

        # TODO: Возможно, здесь должна быть обработка кликов в игре, не связанных с инвентарем или UI
        # Например, взаимодействие с объектами мира

        return True # Этот return в handle_mouse_down не влияет на цикл событий, он для внутренней логики

    def handle_mouse_up(self, pos):
        """Обработка отпускания кнопки мыши"""
        self.dragging = None

    def handle_mouse_motion(self, pos):
        """Обработка движения мыши"""
        if self.dragging:
            self.update_slider_value(self.dragging, pos[0])

    def update_slider_value(self, slider_type, x_pos):
        """Обновление значения слайдера"""
        if slider_type in ['sound', 'music', 'fps']:
            slider_rect = self.settings_elements[f'{slider_type}_slider']
            relative_x = max(0, min(1, (x_pos - slider_rect.x) / slider_rect.width))

            if slider_type == 'sound':
                self.game_manager.settings['sound_volume'] = relative_x
            elif slider_type == 'music':
                self.game_manager.settings['music_volume'] = relative_x
            elif slider_type == 'fps':
                self.game_manager.settings['fps_limit'] = int(relative_x * 120) + 30  # 30-150 FPS

    def toggle_fullscreen(self):
        """Переключение полноэкранного режима"""
        self.game_manager.settings['fullscreen'] = not self.game_manager.settings['fullscreen']
        self.game_manager.toggle_fullscreen()



==================== game_manager.py ====================

import pygame
from src.shop import Shop
from src.game_state import GameState
from src.screen_manager import ScreenManager
from src.event_handler import EventHandler
from src.render_manager import RenderManager
from src.player import Player
from src.camera import Camera
from src.plant import Plant
from src.item import Tool, Item, Seed # Импортируем также базовый класс Item
import pytmx
import os
import math
import time
from src.inventory_manager import InventoryManager

class GameManager:
    def __init__(self):
        pygame.init()
        pygame.font.init()

        self.screen_manager = ScreenManager()
        self.event_handler = EventHandler(self)
        self.render_manager = RenderManager(self.screen_manager)

        self.state = GameState.MENU
        self.running = True
        self.paused = False

        self.clock = pygame.time.Clock()
        self.clock_size = 75
        self.clock_bg = None
        self.clock_arrow = None
        self.clock_pos = None

        # игровое время
        self.game_time = 300 # Начинаем с начала дня для отладки
        self.last_time_update = 0 # последнее обновление

        # затемнение
        self.night_overlay = None
        self.is_night = False

        self.settings = {
            'sound_volume': 0.7,
            'music_volume': 0.5,
            'fullscreen': False,
            'fps_limit': 60,
            'vsync': True,
            'language': 'en',
            'controls': {
                'up': pygame.K_w,
                'down': pygame.K_s,
                'left': pygame.K_a,
                'right': pygame.K_d,
                'interact': pygame.K_e,
                'inventory': pygame.K_i,
                'menu': pygame.K_ESCAPE #настройки
            }
        }

        self.fonts = {
            'small': pygame.font.Font(None, 24),
            'medium': pygame.font.Font(None, 36),
            'large': pygame.font.Font(None, 48)
        }

        # Инициализация инструментов
        self.tools = {} # Инициализируем пустой словарь инструментов

        # --- Загрузка изображений инструментов и создание объектов Tool ---
        # Используем более надежный способ формирования пути
        base_sprites_path = os.path.join("sprites", "player", "sprites_tools")
        hoe_image_path = os.path.join(base_sprites_path, 'hoe.png')

        try:
             hoe_image = pygame.image.load(hoe_image_path).convert_alpha()
             print(f"Изображение мотыги успешно загружено по пути: {hoe_image_path}")
             self.tools['hoe'] = Tool('Мотыга', hoe_image, 'hoe')
        except pygame.error as e:
             print(f"Ошибка загрузки изображения мотыги: {e}")
             print(f"Проверьте путь к файлу: {hoe_image_path}")
        except Exception as e:
             print(f"Произошла другая ошибка при создании объекта Tool для мотыги: {e}")


        # Добавьте загрузку и создание объектов для других инструментов аналогично
        # axe_image_path = os.path.join(base_sprites_path, 'axe.png')
        # try:
        #      axe_image = pygame.image.load(axe_image_path).convert_alpha()
        #      self.tools['axe'] = Tool('Топор', axe_image, 'axe')
        # except pygame.error as e:
        #      print(f"Ошибка загрузки изображения топора: {e}")
        #      print(f"Проверьте путь к файлу: {axe_image_path}")

        self.inventory_manager = InventoryManager(self)

        self.all_sprites = pygame.sprite.Group()
        self.players = pygame.sprite.Group()
        
        self.npcs = pygame.sprite.Group()
        self.obstacles = pygame.sprite.Group()
        self.items = pygame.sprite.Group()
        self.plants = pygame.sprite.Group()

        # Загрузка карты
        self.map_loaded = False
        self.tmx_data = None # Инициализируем до try/except

        self.soil_layer = 'Песочек' # Будет содержать объект слоя TiledTileLayer
        self.grass_layer = 'Травка' # Будет содержать объект слоя TiledTileLayer
        self.dirt_tile_gid = None # Будет содержать GID тайла земли

        # Слои коллизий (имена слоев из Tiled)
        self.collision_layers_names = ["Коллизия лес", "Колилзия горок", "Дом", "Коллизия кусты","Коллизии Мосты", "Коллизия камней", "Коллизии река и Озеро"]
        self.collision_layers = [] # Будет содержать объекты TiledTileLayer для коллизий


        try:
            # Используем более надежный способ формирования пути к карте
            map_path = os.path.join('maps', 'maps.tmx')
            self.tmx_data = pytmx.load_pygame(map_path)
            self.map_loaded = True
            print(f"Карта успешно загружена по пути: {map_path}")

            # Получаем объекты слоев после успешной загрузки карты
            self.soil_layer = self.tmx_data.get_layer_by_name('Песочек')
            self.grass_layer = self.tmx_data.get_layer_by_name('Травка')

            # Получаем объекты слоев коллизий
            for layer_name in self.collision_layers_names:
                 layer = self.tmx_data.get_layer_by_name(layer_name)
                 if layer and isinstance(layer, pytmx.TiledTileLayer):
                      self.collision_layers.append(layer)
                 else:
                     print(f"Предупреждение: Слой коллизии '{layer_name}' не найден или не является тайловым слоем.")


            # Получаем GID тайла земли по свойству
            self.dirt_tile_gid = self.get_tile_gid_by_property('type', 'dirt')

            # Проверки наличия слоев и GID
            if not self.soil_layer:
                print("Внимание: Слой 'Песочек' не найден в карте. Вспашка не будет работать корректно.")
            if not self.grass_layer:
                 print("Внимание: Слой 'Травка' не найден в карте. Вспашка не будет работать корректно.")
            if self.dirt_tile_gid is None:
                 print("Внимание: GID тайла земли не найден по свойству 'type'='dirt'. Вспашка не будет работать корректно.")

        except FileNotFoundError:
             print(f"Ошибка загрузки карты: Файл карты не найден по пути: {map_path}")
             self.map_loaded = False
        except Exception as e:
            print(f"Ошибка загрузки карты: {e}")
            self.map_loaded = False


        screen = self.screen_manager.get_screen()
        self.camera = Camera(screen.get_width(), screen.get_height())
        print(f"Камера создана с размерами {screen.get_width()}x{screen.get_height()}")

        self.init_clock(screen)

        if self.map_loaded and hasattr(self, 'tmx_data'):
            map_width = self.tmx_data.width * self.tmx_data.tilewidth
            map_height = self.tmx_data.height * self.tmx_data.tileheight
            self.camera.set_map_size(map_width, map_height)
            print(f"Размеры карты для камеры установлены: {map_width}x{map_height}")

        self.init_game_objects()

        # Счётчик FPS
        self.fps = 0
        self.fps_counter = 0
        self.fps_timer = pygame.time.get_ticks()
        self.shop = Shop(self)

        self.tile_states = {}  # Словарь или двумерный список для хранения состояния тайлов

        print("GameManager инициализирован успешно")

    # --- Методы для мотыги и инвентаря ---

    def get_tile_gid_by_property(self, property_name, property_value):
        """
        Вспомогательный метод для поиска GID тайла по его свойству,
        используя get_tile_properties_by_gid.
        """
        if not self.tmx_data:
            print("tmx_data не загружена в get_tile_gid_by_property")
            return None

        # Собираем все уникальные GID, используемые в карте и тайлсетах
        used_gids = set()

        # Собираем GIDы из слоев карты (это может быть полезно, но не обязательно для поиска по тайлсету)
        # for layer in self.tmx_data.visible_layers:
        #     if hasattr(layer, 'data'):
        #         # Используем метод tiles() слоя, который итерирует по (x, y, gid)
        #         for x, y, gid in layer.tiles():
        #             if gid != 0:
        #                 used_gids.add(gid)

        # Добавляем GIDы из всех тайлсетов - это основной способ найти GID по свойству тайлсета
        for tileset in self.tmx_data.tilesets:
            # Проверяем, что tileset имеет firstgid и tilecount
            if hasattr(tileset, 'firstgid') and hasattr(tileset, 'tilecount'):
                 # Итерируем по всем локальным ID тайлов в тайлсете
                 for tile_id in range(tileset.tilecount):
                      # Вычисляем глобальный GID
                      gid = tileset.firstgid + tile_id
                      used_gids.add(gid)


        # Проверяем свойства для каждого уникального GID, используя get_tile_properties_by_gid
        for gid in sorted(list(used_gids)): # Сортируем для предсказуемого порядка
            # !!! ИСПОЛЬЗУЕМ ПРАВИЛЬНЫЙ МЕТОД: get_tile_properties_by_gid !!!
            tile_properties = self.tmx_data.get_tile_properties_by_gid(gid)

            # Проверяем свойства тайла
            if tile_properties and property_name in tile_properties and tile_properties[property_name] == property_value:
                 print(f"  Найден тайл с нужным свойством: GID {gid}")
                 return gid # Возвращаем глобальный GID

        print(f"Не найден тайл со свойством '{property_name}'='{property_value}'")
        return None


    def init_game_objects(self):
        spawn_point = self.get_spawn_point()
        if spawn_point:
            start_x, start_y = spawn_point
        else:
            screen = self.screen_manager.get_screen()
            start_x = screen.get_width() // 2
            start_y = screen.get_height() // 2

        # При создании игрока передаем ссылку на GameManager
        # Важно: Игрок может нуждаться в ссылке на InventoryManager для использования предметов
        self.player = Player(self, start_x, start_y)
        self.all_sprites.add(self.player)
        self.players.add(self.player)
        print(f"Игрок создан на позиции ({start_x}, {start_y})")

        if 'hoe' in self.tools:
            print("Мотыга найдена в self.tools.")
            if hasattr(self, 'inventory_manager') and isinstance(self.inventory_manager, InventoryManager):
                success = self.inventory_manager.add_item_to_inventory(self.tools['hoe'], slot_index=0)
                if success:
                    print("Мотыга добавлена в инвентарь игрока через InventoryManager.")
                else:
                    print("Ошибка: Не удалось добавить мотыгу в инвентарь через InventoryManager.")
            else:
                print("Ошибка: InventoryManager не инициализирован или имеет неправильный тип.")
        else:
            print("Ошибка: Мотыга не найдена в словаре self.tools или не была загружена.")
            # --- Конец блока изменения для мотыги ---
            # --- Добавляем семена пшеницы и томатов в инвентарь игрока ---
        try:
            # Путь к спрайтам предметов (семян)
            item_sprites_path = os.path.join("sprites", "items")  # Предполагаем, что спрайты предметов тут
            # Загружаем изображения для семян пшеницы и томатов
            wheat_seed_image_path = os.path.join(item_sprites_path, "wheat_plant.png")  # Используем wheat_plant.png
            tomato_seed_image_path = os.path.join(item_sprites_path, "tomato_plant.png")  # Используем tomato_plant.png
            wheat_seed_image = None
            tomato_seed_image = None
            try:
                wheat_seed_image = pygame.image.load(wheat_seed_image_path).convert_alpha()
                print(f"Изображение семян пшеницы успешно загружено: {wheat_seed_image_path}")
            except pygame.error as e:
                print(f"Ошибка загрузки изображения семян пшеницы: {e}")
                print(f"Проверьте путь к файлу: {wheat_seed_image_path}")
                # Используем заглушку, если изображение не найдено
                wheat_seed_image = pygame.Surface((32, 32))
                wheat_seed_image.fill((210, 180, 140))  # Цвет пшеницы для заглушки
            try:
                tomato_seed_image = pygame.image.load(tomato_seed_image_path).convert_alpha()
                print(f"Изображение семян томатов успешно загружено: {tomato_seed_image_path}")
            except pygame.error as e:
                print(f"Ошибка загрузки изображения семян томатов: {e}")
                print(f"Проверьте путь к файлу: {tomato_seed_image_path}")
                # Используем заглушку, если изображение не найдено
                tomato_seed_image = pygame.Surface((32, 32))
                tomato_seed_image.fill((255, 99, 71))  # Цвет томата для заглушки
            # Создаем экземпляры семян, передавая тип растения
            wheat_seed = Seed("Семена пшеницы", wheat_seed_image, "wheat")  # Тип растения 'wheat'
            tomato_seed = Seed("Семена томатов", tomato_seed_image, "tomato")  # Тип растения 'tomato'
            # Добавляем семена в инвентарь (например, в следующие слоты хотбара)
            if hasattr(self, 'inventory_manager') and isinstance(self.inventory_manager, InventoryManager):
                # Добавляем пшеницу во 2-й слот (индекс 1)
                self.inventory_manager.add_item_to_inventory(wheat_seed, slot_index=1)
                # Добавляем томаты в 3-й слот (индекс 2)
                self.inventory_manager.add_item_to_inventory(tomato_seed, slot_index=2)
                print("Семена пшеницы и томатов добавлены в инвентарь игрока.")
            else:
                print("Ошибка: InventoryManager не инициализирован при попытке добавить семена.")
        except Exception as e:
            print(f"Произошла ошибка при создании или добавлении семян в инвентарь: {e}")

    def is_tile_plantable(self, tile_x, tile_y):
        """Проверяет, можно ли посадить семя на данном тайле."""
        if not self.tmx_data:
             print("Ошибка в is_tile_plantable: tmx_data не загружена.")
             return False
        map_width_tiles = self.tmx_data.width
        map_height_tiles = self.tmx_data.height
        if not (0 <= tile_x < map_width_tiles and 0 <= tile_y < map_height_tiles):
            # print(f"Координаты тайла ({tile_x}, {tile_y}) вне границ карты.") # Можно убрать для чистоты лога
            return False # Вне границ карты сажать нельзя
        # Проверяем состояние тайла в нашей структуре tile_states
        tile_coords = (tile_x, tile_y)
        state = self.tile_states.get(tile_coords, {}) # Получаем состояние или пустой словарь
        # Можно сажать, если земля вспахана ('is_tilled' == True) И на ней нет растения ('has_plant' == False или отсутствует)
        return state.get('is_tilled', False) and not state.get('has_plant', False)

    def till_tile(self, tile_x, tile_y):
        """
        Изменяет тайл травы на тайл земли по указанным координатам и
        обновляет состояние тайла для посадки.
        """
        print(f"Попытка вспахать клетку: ({tile_x}, {tile_y})") # Начало метода
        if not self.tmx_data or not self.soil_layer or not isinstance(self.soil_layer, pytmx.TiledTileLayer) or \
           not self.grass_layer or not isinstance(self.grass_layer, pytmx.TiledTileLayer) or self.dirt_tile_gid is None:
            print("Ошибка в till_tile: Не все необходимые данные карты загружены или имеют правильный тип. Возврат.")
            return
        tile_width = self.tmx_data.tilewidth
        tile_height = self.tmx_data.tileheight
        map_width_tiles = self.tmx_data.width
        map_height_tiles = self.tmx_data.height
        if not (0 <= tile_x < map_width_tiles and 0 <= tile_y < map_height_tiles):
            print(f"Предупреждение в till_tile: Координаты ({tile_x}, {tile_y}) вне границ карты. Возврат.")
            return
        # Получаем GID тайла на слое травы по координатам
        gid = self.grass_layer.data[tile_y][tile_x]
        # print(f"GID тайла на слое '{self.grass_layer.name}' по координатам ({tile_x}, {tile_y}): {gid}") # Отладочный вывод
        if gid != 0: # Проверяем, что на этой клетке есть тайл (не пустая)
            # print(f"Найдена непустая клетка с GID: {gid}") # Отладочный вывод
            # Получаем свойства тайла травы на этой позиции
            try:
                grass_layer_index = -1
                for i, layer in enumerate(self.tmx_data.layers):
                    if layer is self.grass_layer:
                        grass_layer_index = i
                        break
                if grass_layer_index == -1:
                    print(f"Ошибка в till_tile: Объект слоя травы не найден в списке слоев карты. Возврат.")
                    return
                tile_properties = self.tmx_data.get_tile_properties(tile_x, tile_y, grass_layer_index)
                # print(f"Свойства тайла (GID {gid}): {tile_properties}") # Отладочный вывод
            except Exception as e:
                 print(f"Ошибка при получении свойств тайла травы в till_tile на ({tile_x}, {tile_y}): {e}")
                 tile_properties = None
            # Проверяем, является ли тайл травой (по свойству)
            if tile_properties and isinstance(tile_properties, dict) and tile_properties.get('type') == 'grass':
                print("Тайл является травой. Производим вспашку.") # Отладочный вывод
                # Изменяем тайл на слое травы на тайл земли (или просто удаляем тайл травы, если земля находится на другом слое)
                if self.soil_layer and isinstance(self.soil_layer, pytmx.TiledTileLayer) and self.dirt_tile_gid is not None:
                    self.grass_layer.data[tile_y][tile_x] = 0 # Удаляем тайл травы
                    # Опционально: ставим тайл вспаханной земли на слой "Песочек"
                    # self.soil_layer.data[tile_y][tile_x] = self.dirt_tile_gid
                    print(f"Тайл травы на ({tile_x}, {tile_y}) удален.")
                else:
                     self.grass_layer.data[tile_y][tile_x] = self.dirt_tile_gid
                     print(f"Тайл на ({tile_x}, {tile_y}) изменен на GID земли ({self.dirt_tile_gid}).")
                # --- Обновляем состояние тайла для посадки ---
                tile_coords = (tile_x, tile_y)
                if tile_coords not in self.tile_states:
                     self.tile_states[tile_coords] = {}
                self.tile_states[tile_coords]['is_tilled'] = True
                # Убедимся, что нет растения при вспашке
                self.tile_states[tile_coords]['has_plant'] = False
                print(f"Состояние тайла ({tile_x}, {tile_y}) обновлено: {self.tile_states[tile_coords]}")
            else:
                 # print(f"Тайл не является травой или не имеет нужного свойства. Свойства: {tile_properties}. Требуется: {{'type': 'grass'}}") # Отладочный вывод
                 pass # Нет необходимости в отладочном выводе для каждого не-травяного тайла
        else:
             # print("Клетка пустая (GID 0). Вспашка не требуется.") # Отладочный вывод
             pass # Нет необходимости в отладочном выводе для пустых клеток

    def update_tile_state(self, tile_x, tile_y, **kwargs):
        """Обновляет состояние тайла по указанным координатам."""
        tile_coords = (tile_x, tile_y)
        if tile_coords not in self.tile_states:
            self.tile_states[tile_coords] = {}
        self.tile_states[tile_coords].update(kwargs)
        # print(f"Состояние тайла ({tile_x}, {tile_y}) обновлено: {self.tile_states[tile_coords]}") # Отладочный вывод

    # --- Методы обработки событий и отрисовки ---

    def handle_events(self):
        """
        Обработка всех событий Pygame и их распределение по соответствующим менеджерам.
        Включает обработку общих событий, инвентаря и взаимодействия с магазином.
        """
        events = pygame.event.get()
        keys = pygame.key.get_pressed()  # Получаем состояние клавиш
        for event in events:
            if event.type == pygame.QUIT:
                self.running = False
                return False # Сигнализируем, что игра должна завершиться
            # --- Передача события Event Handler ---
            # Сначала обрабатываем общие события (меню, пауза и т.д.)
            if not self.event_handler.handle_events(event):
                # Event Handler может установить self.running = False
                # или изменить состояние игры (например, на GameState.QUIT)
                # Если Event Handler возвращает False, завершаем обработку событий
                return False
            # --- Передача события игроку ---
            # Передаем событие игроку только если игра в состоянии GAME
            if self.state == GameState.GAME and hasattr(self, 'player') and self.player:
                self.player.handle_input(event)
            # --- Передача события инвентарю ---
            # Инвентарь должен обрабатывать события всегда, чтобы его можно было открыть/закрыть
            if hasattr(self, 'inventory_manager') and self.inventory_manager:
                 self.inventory_manager.handle_input(event)
            # --- Обработка взаимодействия с магазином ---
            # Обрабатываем событие только если магазин инициализирован
            if hasattr(self, 'shop') and isinstance(self.shop, Shop):
                 # Обработка открытия/закрытия магазина по клавише взаимодействия
                 if event.type == pygame.KEYDOWN and event.key == self.settings['controls']['interact']:
                     # Проверяем, находится ли игрок в зоне магазина и инвентарь закрыт
                     if not self.inventory_manager.inventory_open and self.shop.is_player_in_range():
                         self.shop.toggle_shop()
                         print("Магазин открыт/закрыт")
                     # Если магазин открыт, клики вне инвентаря могут быть для магазина
                     elif self.shop.is_open:
                          # Дополнительная логика для магазина при клике мыши (если нужна)
                          if event.type == pygame.MOUSEBUTTONDOWN:
                               pass # TODO: Добавить логику обработки кликов в магазине
        # Вызов handle_input для магазина (если он открыт)
        # Обработка ввода с клавиатуры в магазине (например, для выбора предметов)
        if hasattr(self, 'shop') and self.shop.is_open:
            self.shop.handle_input(keys, events) # Передаем состояние клавиш и список событий
        return True # Возвращаем True, если игра должна продолжаться

    def update(self):
        """Обновляет состояние игры"""
        delta_time = self.clock.tick(self.settings['fps_limit']) / 1000.0
        if self.state == GameState.GAME and not self.paused:
            # Сначала обновляем спрайты (включая игрока и растения)
            self.all_sprites.update(delta_time)
            self.plants.update(delta_time) # !!! Обновляем группу растений !!!
            # Обновляем камеру, привязывая её к игроку
            self.camera.update(self.player)
            self.update_clock()
            # Подсчёт FPS
            self.fps_counter += 1
            current_time = pygame.time.get_ticks()
            if current_time - self.fps_timer >= 1000:
                self.fps = self.fps_counter
                self.fps_counter = 0
                self.fps_timer = current_time

    def draw(self):
        """Отрисовка текущего состояния игры"""
        screen = self.screen_manager.get_screen()
        if self.state == GameState.MENU:
            self.render_manager.draw_menu(self)
        elif self.state == GameState.SETTINGS:
            self.render_manager.draw_settings(self)
        elif self.state == GameState.GAME:
            # Очистка экрана
            screen.fill((50, 50, 50))  # Серый фон
            # Отрисовка только видимой части карты
            if self.map_loaded:
                self.render_map(screen)
            # Отрисовка всех спрайтов (включая игрока)
            # Сортируем спрайты по нижней границе для правильной отрисовки (персонажи перед растениями)
            all_sprites_except_plants = [s for s in self.all_sprites if
                                         not isinstance(s, Plant)]  # Исключаем растения из основной группы отрисовки
            all_sprites_sorted = sorted(all_sprites_except_plants, key=lambda sprite: sprite.rect.bottom)
            for sprite in all_sprites_sorted:
                pos = self.camera.apply(sprite)
                screen.blit(sprite.image, pos.topleft)
            # !!! Отрисовка растений !!!
            # Растения также являются спрайтами и будут отрисовываться вместе с all_sprites
            # Если нужно отдельное управление отрисовкой растений, можно отрисовывать self.plants здесь
            self.draw_clock(screen)
            # Отрисовка интерфейса (всегда поверх всего остального)
            self.inventory_manager.draw(screen)
            self.shop.draw(screen)
            self.player.draw_coins(screen)
            # Отрисовка FPS (для отладки)
            fps_text = self.fonts['small'].render(f"FPS: {self.fps}", True, (255, 255, 255))
            screen.blit(fps_text, (10, 10))
        # Обновление экрана
        pygame.display.flip()

    def init_clock(self, screen):
        screen_width = screen.get_width()
        screen_height = screen.get_height()
        offset = 10
        self.clock_pos = (screen_width - self.clock_size - offset, offset)

        # Загрузка изображений часов
        try:
            clock_bg_path = os.path.join("sprites", "clock", "clock_bg.png")
            clock_arrow_path = os.path.join("sprites", "clock", "clock_arrow.png")
            self.clock_bg = pygame.image.load(clock_bg_path).convert_alpha()
            self.clock_arrow = pygame.image.load(clock_arrow_path).convert_alpha()
            print("Изображения часов успешно загружены.")
        except pygame.error as e:
            print(f"Ошибка загрузки изображений часов: {e}")
            print("Создаются заглушки для часов.")
            # Создаем заглушки, если изображения не найдены
            self.clock_bg = pygame.Surface((self.clock_size, self.clock_size), pygame.SRCALPHA)
            pygame.draw.circle(self.clock_bg, (200, 200, 200), (self.clock_size//2, self.clock_size//2), self.clock_size//2)
            self.clock_arrow = pygame.Surface((self.clock_size, self.clock_size), pygame.SRCALPHA)
            pygame.draw.rect(self.clock_arrow, (50, 50, 50),
                            (self.clock_size//2 - 2, 10, 4, self.clock_size//2))
        except Exception as e:
             print(f"Произошла другая ошибка при инициализации часов: {e}")
             # Создаем заглушки в случае других ошибок
             self.clock_bg = pygame.Surface((self.clock_size, self.clock_size), pygame.SRCALPHA)
             pygame.draw.circle(self.clock_bg, (200, 200, 200), (self.clock_size//2, self.clock_size//2), self.clock_size//2)
             self.clock_arrow = pygame.Surface((self.clock_size, self.clock_size), pygame.SRCALPHA)
             pygame.draw.rect(self.clock_arrow, (50, 50, 50),
                            (self.clock_size//2 - 2, 10, 4, self.clock_size//2))


        # если нужен будет рескейл
        # self.clock_bg = pygame.transform.scale(self.clock_bg, (self.clock_size, self.clock_size))
        # self.clock_arrow = pygame.transform.scale(self.clock_arrow, (self.clock_size, self.clock_size))

        self.night_overlay = pygame.Surface((screen_width, screen_height), pygame.SRCALPHA)
        self.night_overlay.fill((0, 0, 0, 180))


    def draw_clock(self, screen):
        if self.clock_bg: # Проверяем, что изображение фона часов загружено
            screen.blit(self.clock_bg, self.clock_pos)

            if self.clock_arrow: # Проверяем, что изображение стрелки часов загружено
                angle = math.radians(self.game_time * -0.5) # Угол в радианах (умножаем на -0.5 для вращения по часовой стрелке)
                # Вращаем стрелку
                rotated_arrow = pygame.transform.rotate(self.clock_arrow, math.degrees(angle))
                # Получаем прямоугольник повернутой стрелки и центрируем его по центру фона часов
                arrow_rect = rotated_arrow.get_rect(center=(
                    self.clock_pos[0] + self.clock_size // 2,
                    self.clock_pos[1] + self.clock_size // 2
                ))
                screen.blit(rotated_arrow, arrow_rect)
            else:
                 print("Предупреждение: Изображение стрелки часов не загружено.")

        else:
            print("Предупреждение: Изображение фона часов не загружено.")


        # Отрисовка затемнения (ночи)
        if self.is_night and self.night_overlay: # Проверяем наличие night_overlay
            screen.blit(self.night_overlay, (0, 0))
        elif self.is_night and not self.night_overlay:
            print("Предупреждение: night_overlay не инициализирован, но is_night = True.")


    def update_clock(self):
        # для дебага
        # print(f"Time: {self.game_time}, Minute: {(self.game_time // 60) % 12}, Night: {self.is_night}")

        current_time = time.time()
        # Обновляем игровое время каждую секунду реального времени
        if current_time - self.last_time_update >= 1:
            self.game_time += 1 # Увеличиваем на 1 секунду
            self.last_time_update = current_time

        # Пример: день 12 минут (720 секунд) игрового времени = 12 реальных минут
        # 12 игровых часов = 720 секунд игрового времени
        # 1 игровой час = 60 секунд игрового времени

        max_game_time = 720 # Максимальное игровое время в цикле

        if self.game_time >= max_game_time:
            self.game_time = 0 # Сбрасываем игровое время в начало нового дня

        # Пример: ночь с 11-го до 5-го часа (по циферблату)
        # 11-й час начинается с (11 * 60) = 660 секунды
        # 5-й час заканчивается в (5 * 60) = 300 секунд (на следующий день)
        # То есть ночь с 660 до 720 (конец дня) и с 0 до 300 (начало дня)
        self.is_night = (self.game_time >= 660) or (self.game_time < 300) # Исправлено условие для начала дня

    def render_map(self, screen):
        """Отрисовка карты"""
        if not self.map_loaded or not self.tmx_data:
            return

        # Получаем смещение камеры
        camera_offset = self.camera.offset

        # Размер тайла
        tile_width = self.tmx_data.tilewidth
        tile_height = self.tmx_data.tileheight

        # Вычисляем видимую область в тайлах (с небольшим запасом)
        start_x = int(camera_offset.x) // tile_width
        end_x = start_x + (screen.get_width() // tile_width) + 2
        start_y = int(camera_offset.y) // tile_height
        end_y = start_y + (screen.get_height() // tile_height) + 2

        # Ограничиваем индексы границами карты
        start_x = max(0, start_x)
        start_y = max(0, start_y)
        end_x = min(self.tmx_data.width, end_x)
        end_y = min(self.tmx_data.height, end_y)

        # Отрисовка видимых тайлов слоев с данными
        for layer in self.tmx_data.visible_layers:
            # Отрисовываем только тайловые слои с данными
            if isinstance(layer, pytmx.TiledTileLayer): # Проверяем, что это тайловый слой
                 for y in range(start_y, end_y):
                     for x in range(start_x, end_x):
                         # Используем .tile для доступа к GID на позиции (x, y) в слое
                         gid = layer.data[y][x] # Исправлено: доступ к данным слоя через .tile

                         if gid != 0: # Проверяем, что это не пустая клетка
                             # Получаем изображение тайла по GID
                             tile_image = self.tmx_data.get_tile_image_by_gid(gid)

                             if tile_image:
                                 # Вычисляем позицию на экране
                                 screen_x = x * tile_width - int(camera_offset.x)
                                 screen_y = y * tile_height - int(camera_offset.y)
                                 screen.blit(tile_image, (screen_x, screen_y))

    def toggle_fullscreen(self):
        self.settings['fullscreen'] = not self.settings['fullscreen']
        self.screen_manager.toggle_screen_mode()
        screen = self.screen_manager.get_screen()
        self.camera = Camera(screen.get_width(), screen.get_height())
        if self.map_loaded and hasattr(self, 'tmx_data'):
            map_width = self.tmx_data.width * self.tmx_data.tilewidth
            map_height = self.tmx_data.height * self.tmx_data.tileheight
            self.camera.set_map_size(map_width, map_height)
            self.init_clock(screen) # Переинициализируем часы после смены размера экрана
        print(f"Переключен режим экрана, новые размеры: {screen.get_width()}x{screen.get_height()}")

    def set_sound_volume(self, volume):
        self.settings['sound_volume'] = max(0.0, min(1.0, volume))
        print(f"Установлена громкость звука: {volume}")

    def set_music_volume(self, volume):
        self.settings['music_volume'] = max(0.0, min(1.0, volume))
        print(f"Установлена громкость музыки: {volume}")

    def save_settings(self):
        print("Настройки сохранены")

    def load_settings(self):
        print("Настройки загружены")

    def run(self):
        self.load_settings()
        while self.running:
            self.handle_events()
            self.update()
            self.draw() # Метод draw теперь отвечает за отрисовку изменений

        self.save_settings()
        pygame.quit()

    def get_spawn_point(self):
        """Ищет точку спавна игрока на слое объектов карты."""
        if self.map_loaded and self.tmx_data:
            for layer in self.tmx_data.layers:
                # Проверяем, является ли слой слоем объектов
                if isinstance(layer, pytmx.TiledObjectGroup):
                    for obj in layer:
                        # Проверяем свойства объекта для определения точки спавна
                        if hasattr(obj, 'type') and obj.type == 'spawn' or \
                           hasattr(obj, 'name') and obj.name == 'player_spawn':
                            print(f"Найдена точка спавна игрока на ({obj.x}, {obj.y})")
                            return obj.x, obj.y
        print("Предупреждение: Точка спавна игрока не найдена на карте. Игрок будет размещен по центру экрана.")
        return None # Возвращаем None, если точка спавна не найдена

    def reset_game(self):
        self.all_sprites.empty()
        self.players.empty()
        self.npcs.empty()
        self.obstacles.empty()
        self.items.empty()
        self.init_game_objects() # Повторно инициализируем объекты игры
        self.state = GameState.MENU
        self.paused = False
        print("Игра сброшена в начальное состояние")

    def check_collision(self, rect):
        """
        Проверяет коллизии данного прямоугольника с тайлами на слоях коллизий.
        Принимает прямоугольник (обычно self.player.collision_rect).
        """
        if not self.map_loaded or not self.tmx_data or not self.collision_layers:
             return False # Нет карты, данных или слоев коллизий

        tile_width = self.tmx_data.tilewidth
        tile_height = self.tmx_data.tileheight

        for layer in self.collision_layers:
            # Итерируем по тайлам в пределах видимой области прямоугольника коллизии
            # Определяем область в тайлах, которую пересекает прямоугольник
            start_x = int(rect.left // tile_width)
            end_x = int(rect.right // tile_width) + 1
            start_y = int(rect.top // tile_height)
            end_y = int(rect.bottom // tile_height) + 1

            # Ограничиваем область границами слоя
            start_x = max(0, start_x)
            start_y = max(0, start_y)
            end_x = min(layer.width, end_x)
            end_y = min(layer.height, end_y)


            for y in range(start_y, end_y):
                for x in range(start_x, end_x):
                     # Используем .tile для доступа к GID на позиции (x, y) в слое
                     gid = layer.data[y][x] # Исправлено: доступ к данным слоя через .tile

                     if gid != 0: # Если тайл не пустой, это коллизия
                        # Создаем прямоугольник для тайла коллизии
                        tile_rect = pygame.Rect(
                            x * tile_width,
                            y * tile_height,
                            tile_width,
                            tile_height,
                        )
                        # Проверяем пересечение прямоугольников
                        if rect.colliderect(tile_rect):
                            # print(f"Коллизия с тайлом на ({x}, {y}) на слое {layer.name}") # Отладочный вывод
                            return True # Найдена коллизия

        return False # Коллизий не найдено


==================== game_state.py ====================

from enum import Enum

class GameState(Enum):
    MENU = 0
    SETTINGS = 1
    GAME = 2
    PAUSE = 3  # Добавим еще и состояние паузы



==================== inventory_manager.py ====================

import pygame
from src.item import Item, Tool # Убедитесь, что путь к Item и Tool правильный

class InventoryManager:
    def __init__(self, game_manager):
        self.game_manager = game_manager  # Ссылка на GameManager для доступа к другим частям игры

        self.inventory_open = False
        self.selected_item_index = 0 # Индекс выбранного слота в хотбаре
        self.hotbar_slots = [None] * 8 # Список для хотбара (8 слотов)
        self.inventory = [[None for _ in range(3)] for _ in range(6)] # Основной инвентарь (6x3 слота)

        # Перетаскивание предметов
        self.dragging_item = None
        self.drag_start_slot = None # Содержит ('hotbar', index) или ('inventory', row, col)
        self.drag_offset = (0, 0)

        # Размеры и позиции для отрисовки (можно вынести в константы или получать из GameManager)
        self.hotbar_slot_size = 50
        self.hotbar_slot_padding = 10
        self.hotbar_panel_padding = 10

        self.inventory_slot_size = 60
        self.inventory_slot_padding = 10
        self.inventory_cols = 3
        self.inventory_rows = 6
        self.inventory_panel_padding = 10 # Добавлена константа для отступа панели инвентаря

    def add_item_to_inventory(self, item, slot_index=None, row=None, col=None):
        # Если предмет стакается, ищем такой же в инвентаре
        if item.stackable:
            # Проверяем хотбар
            for i, slot_item in enumerate(self.hotbar_slots):
                if slot_item and slot_item.name == item.name and slot_item.quantity < slot_item.max_stack:
                    # Увеличиваем количество, если нашли такой же предмет
                    slot_item.quantity += item.quantity
                    return True

            # Проверяем основной инвентарь
            for r in range(self.inventory_rows):
                for c in range(self.inventory_cols):
                    inv_item = self.inventory[r][c]
                    if inv_item and inv_item.name == item.name and inv_item.quantity < inv_item.max_stack:
                        inv_item.quantity += item.quantity
                        return True

        # Если предмет не стакается или не найден подходящий стак, добавляем как обычно
        if slot_index is not None:
            if 0 <= slot_index < len(self.hotbar_slots):
                if self.hotbar_slots[slot_index] is None:
                    self.hotbar_slots[slot_index] = item
                    return True
        elif row is not None and col is not None:
            if 0 <= row < self.inventory_rows and 0 <= col < self.inventory_cols:
                if self.inventory[row][col] is None:
                    self.inventory[row][col] = item
                    return True
        else:
            # Поиск первого свободного слота
            for i in range(len(self.hotbar_slots)):
                if self.hotbar_slots[i] is None:
                    self.hotbar_slots[i] = item
                    return True
            for r in range(self.inventory_rows):
                for c in range(self.inventory_cols):
                    if self.inventory[r][c] is None:
                        self.inventory[r][c] = item
                        return True
        return False

    def handle_input(self, event):
        """Обработка событий ввода, связанных с инвентарем (открытие/закрытие, выбор слота, перетаскивание)"""

        # --- Отладочные принты для проверки принимаемых событий ---
        # print(f"InventoryManager received event type: {event.type}")
        # if event.type == pygame.KEYDOWN:
        #     print(f"Key pressed: {event.key}")
        #     print(f"Expected inventory key: {self.game_manager.settings['controls']['inventory']}")
        # elif event.type == pygame.MOUSEBUTTONDOWN:
        #      print(f"Mouse button down at {event.pos}, button: {event.button}")
        # elif event.type == pygame.MOUSEBUTTONUP:
        #      print(f"Mouse button up at {event.pos}, button: {event.button}")
        # elif event.type == pygame.MOUSEMOTION:
        #      print(f"Mouse motion to {event.pos}")
        # --- Конец отладочных принтов ---


        if event.type == pygame.KEYDOWN:
            # Обработка открытия/закрытия инвентаря клавишей
            if event.key == self.game_manager.settings['controls']['inventory']:
                self.inventory_open = not self.inventory_open
                # print(f"Инвентарь {'открыт' if self.inventory_open else 'закрыт'}") # Отладочный принт

            # Обработка выбора слота хотбара клавишами 1-8 (если инвентарь закрыт)
            # Этот блок у вас уже работает
            if not self.inventory_open:
                for i in range(8):
                    if event.key == getattr(pygame, f'K_{i + 1}'):
                        self.selected_item_index = i
                        # print(f"Выбран слот хотбара: {self.selected_item_index}") # Отладочный принт
                        break

        elif event.type == pygame.MOUSEBUTTONDOWN:
            if event.button == 1:  # Левая кнопка мыши
                mouse_pos = event.pos
                # Проверяем клик только если инвентарь открыт (для перетаскивания)
                if self.inventory_open:
                    item, slot_info = self.get_item_from_click(mouse_pos)
                    if item:
                        self.dragging_item = item
                        self.drag_start_slot = slot_info
                        item_image_rect = self.get_item_image_rect(item, slot_info)
                        if item_image_rect:
                            self.drag_offset = (mouse_pos[0] - item_image_rect.x, mouse_pos[1] - item_image_rect.y)
                        else:
                            self.drag_offset = (0, 0)
                        self._remove_item_from_slot(slot_info)
                        # print(f"Начато перетаскивание предмета {item.name} из {slot_info}") # Отладочный принт
                # TODO: Добавить здесь обработку кликов вне инвентаря (для использования предмета в мире),
                # если эта логика не в Player.handle_input

        elif event.type == pygame.MOUSEBUTTONUP:
            if event.button == 1:  # Левая кнопка мыши
                if self.dragging_item:
                    mouse_pos = event.pos
                    target_slot_info = self.get_slot_from_click(mouse_pos)

                    if target_slot_info:
                        # print(f"Предмет {self.dragging_item.name} брошен в {target_slot_info}") # Отладочный принт
                        success = self.place_item_in_slot(self.dragging_item, target_slot_info, self.drag_start_slot)
                        if not success:
                            # print(f"Не удалось поместить предмет {self.dragging_item.name} в {target_slot_info}. Возврат в исходный слот {self.drag_start_slot}.") # Отладочный принт
                            self.place_item_in_slot(self.dragging_item, self.drag_start_slot) # Вернуть в исходный слот
                    else:
                        # Предмет брошен вне инвентаря (логика выброса)
                        print(f"Предмет {self.dragging_item.name} выброшен.")
                        # Здесь можно добавить логику для создания объекта Item на земле

                    self.dragging_item = None
                    self.drag_start_slot = None
                    self.drag_offset = (0, 0)
                # TODO: Добавить здесь обработку отпускания кликов вне инвентаря

        elif event.type == pygame.MOUSEMOTION:
             # --- Раскомментированный блок для обработки движения мыши ---
             if self.dragging_item:
                 # Позиция перетаскиваемого предмета обновляется при отрисовке.
                 # Здесь можно добавить логику для проверки наведения на слоты,
                 # если хотите визуально подсвечивать целевой слот.
                 pass
             # --- Конец раскомментированного блока ---


    def get_item_from_click(self, mouse_pos):
        """
        Определяет, был ли клик по предмету в инвентаре или хотбаре.
        Возвращает (предмет, информация_о_слоте) или (None, None).
        """
        screen = self.game_manager.screen_manager.get_screen()

        # Проверка хотбара
        panel_width = len(self.hotbar_slots) * (self.hotbar_slot_size + self.hotbar_slot_padding) + self.hotbar_panel_padding
        panel_height = self.hotbar_slot_size + 2 * self.hotbar_panel_padding
        panel_x = (screen.get_width() - panel_width) // 2
        panel_y = screen.get_height() - panel_height - 10

        for index, item in enumerate(self.hotbar_slots):
            slot_x = panel_x + self.hotbar_panel_padding + index * (self.hotbar_slot_size + self.hotbar_slot_padding)
            slot_y = panel_y + self.hotbar_panel_padding
            slot_rect = pygame.Rect(slot_x, slot_y, self.hotbar_slot_size, self.hotbar_slot_size)

            if slot_rect.collidepoint(mouse_pos) and item:
                return (item, ('hotbar', index))

        # Проверка основного инвентаря
        if self.inventory_open: # Проверяем клик по инвентарю только если он открыт
            inventory_width = self.inventory_cols * (self.inventory_slot_size + self.inventory_slot_padding) + self.inventory_panel_padding
            inventory_height = self.inventory_rows * (self.inventory_slot_size + self.inventory_slot_padding) + self.inventory_panel_padding
            inventory_x = (screen.get_width() - inventory_width) // 2
            inventory_y = (screen.get_height() - inventory_height) // 2

            for row in range(self.inventory_rows):
                for col in range(self.inventory_cols):
                    slot_x = inventory_x + self.inventory_panel_padding + col * (self.inventory_slot_size + self.inventory_slot_padding)
                    slot_y = inventory_y + self.inventory_panel_padding + row * (self.inventory_slot_size + self.inventory_slot_padding)
                    slot_rect = pygame.Rect(slot_x, slot_y, self.inventory_slot_size, self.inventory_slot_size)

                    if slot_rect.collidepoint(mouse_pos):
                        item = self.inventory[row][col]
                        if item:
                            return (item, ('inventory', row, col))

        return (None, None)

    def get_slot_from_click(self, mouse_pos):
        """
        Определяет, в какой слот инвентаря или хотбара был клик.
        Возвращает информация_о_слоте или None.
        """
        screen = self.game_manager.screen_manager.get_screen()

        # Проверка хотбара
        panel_width = len(self.hotbar_slots) * (self.hotbar_slot_size + self.hotbar_slot_padding) + self.hotbar_panel_padding
        panel_height = self.hotbar_slot_size + 2 * self.hotbar_panel_padding
        panel_x = (screen.get_width() - panel_width) // 2
        panel_y = screen.get_height() - panel_height - 10

        for index in range(len(self.hotbar_slots)):
            slot_x = panel_x + self.hotbar_panel_padding + index * (self.hotbar_slot_size + self.hotbar_slot_padding)
            slot_y = panel_y + self.hotbar_panel_padding
            slot_rect = pygame.Rect(slot_x, slot_y, self.hotbar_slot_size, self.hotbar_slot_size)

            if slot_rect.collidepoint(mouse_pos):
                return ('hotbar', index)

        # Проверка основного инвентаря
        if self.inventory_open: # Проверяем клик по инвентарю только если он открыт
            inventory_width = self.inventory_cols * (self.inventory_slot_size + self.inventory_slot_padding) + self.inventory_panel_padding
            inventory_height = self.inventory_rows * (self.inventory_slot_size + self.inventory_slot_padding) + self.inventory_panel_padding
            inventory_x = (screen.get_width() - inventory_width) // 2
            inventory_y = (screen.get_height() - inventory_height) // 2

            for row in range(self.inventory_rows):
                for col in range(self.inventory_cols):
                    slot_x = inventory_x + self.inventory_panel_padding + col * (self.inventory_slot_size + self.inventory_slot_padding)
                    slot_y = inventory_y + self.inventory_panel_padding + row * (self.inventory_slot_size + self.inventory_slot_padding)
                    slot_rect = pygame.Rect(slot_x, slot_y, self.inventory_slot_size, self.inventory_slot_size)

                    if slot_rect.collidepoint(mouse_pos):
                        return ('inventory', row, col)

        return None

    def get_item_image_rect(self, item, slot_info):
        """
        Возвращает pygame.Rect изображения предмета в заданном слоте для расчета смещения.
        Использует те же координаты и размеры, что и при отрисовке.
        """
        screen = self.game_manager.screen_manager.get_screen()

        # Убедитесь, что item является экземпляром Item и имеет изображение
        if not isinstance(item, Item) or not hasattr(item, 'image') or not item.image:
            return None # Возвращаем None, если предмет невалиден для отрисовки

        item_image = item.image
        img_width, img_height = item_image.get_size()

        if slot_info[0] == 'hotbar':
            index = slot_info[1]
            panel_width = len(self.hotbar_slots) * (self.hotbar_slot_size + self.hotbar_slot_padding) + self.hotbar_panel_padding
            panel_height = self.hotbar_slot_size + 2 * self.hotbar_panel_padding
            panel_x = (screen.get_width() - panel_width) // 2
            panel_y = screen.get_height() - panel_height - 10
            slot_x = panel_x + self.hotbar_panel_padding + index * (self.hotbar_slot_size + self.hotbar_slot_padding)
            slot_y = panel_y + self.hotbar_panel_padding

            item_slot_size = 40 # Размер для отрисовки в слоте хотбара

            scale_factor = min(item_slot_size / img_width, item_slot_size / img_height)
            scaled_width = int(img_width * scale_factor)
            scaled_height = int(img_height * scale_factor)

            img_x = slot_x + (self.hotbar_slot_size - scaled_width) // 2
            img_y = slot_y + (self.hotbar_slot_size - scaled_height) // 2

            return pygame.Rect(img_x, img_y, scaled_width, scaled_height)

        elif slot_info[0] == 'inventory':
            row, col = slot_info[1], slot_info[2]
            inventory_width = self.inventory_cols * (self.inventory_slot_size + self.inventory_slot_padding) + self.inventory_panel_padding
            inventory_height = self.inventory_rows * (self.inventory_slot_size + self.inventory_slot_padding) + self.inventory_panel_padding
            inventory_x = (screen.get_width() - inventory_width) // 2
            inventory_y = (screen.get_height() - inventory_height) // 2
            slot_x = inventory_x + self.inventory_panel_padding + col * (self.inventory_slot_size + self.inventory_slot_padding)
            slot_y = inventory_y + self.inventory_panel_padding + row * (self.inventory_slot_size + self.inventory_slot_padding)

            item_slot_size = 50 # Размер для отрисовки в слоте инвентаря

            scale_factor = min(item_slot_size / img_width, item_slot_size / img_height)
            scaled_width = int(img_width * scale_factor)
            scaled_height = int(img_height * scale_factor)

            img_x = slot_x + (self.inventory_slot_size - scaled_width) // 2
            img_y = slot_y + (self.inventory_slot_size - scaled_height) // 2

            return pygame.Rect(img_x, img_y, scaled_width, scaled_height)

        return None # Неизвестный тип слота

    def place_item_in_slot(self, item, target_slot_info, source_slot_info=None):
        """
        Помещает предмет в целевой слот.
        Возвращает True при успехе, False при неудаче.
        Обрабатывает обмен и стакание (пока простая версия).
        """
        if not item:
            # print("Попытка поместить None.") # Отладочный принт
            return False

        target_type = target_slot_info[0]
        target_index_or_coords = target_slot_info[1:]

        # Получаем текущий предмет в целевом слоте
        current_item_in_target = None
        if target_type == 'hotbar':
            target_index = target_index_or_coords[0]
            if 0 <= target_index < len(self.hotbar_slots):
                 current_item_in_target = self.hotbar_slots[target_index]
            else:
                print(f"Неверный целевой хотбар слот: {target_slot_info}")
                return False
        elif target_type == 'inventory':
            target_row, target_col = target_index_or_coords
            if 0 <= target_row < self.inventory_rows and 0 <= target_col < self.inventory_cols:
                 current_item_in_target = self.inventory[target_row][target_col]
            else:
                 print(f"Неверный целевой инвентарь слот: {target_slot_info}")
                 return False
        else:
            print(f"Неизвестный целевой слот: {target_slot_info}")
            return False

        # Логика размещения
        if current_item_in_target is None:
            # Целевой слот пуст - просто помещаем предмет
            if target_type == 'hotbar':
                self.hotbar_slots[target_index] = item
            elif target_type == 'inventory':
                self.inventory[target_row][target_col] = item
            # print(f"Предмет {item.name} помещен в целевой слот {target_slot_info}.") # Отладочный принт
            return True

        else:
            # Целевой слот занят - попытка обмена или стакания
            # Простая логика обмена: если предмет в целевом слоте не None, меняем местами
            # print(f"Целевой слот {target_slot_info} занят предметом {current_item_in_target.name}. Попытка обмена.") # Отладочный принт

            if source_slot_info:
                # Удаляем предмет из исходного слота перед обменом
                 self._remove_item_from_slot(source_slot_info)
                 # Помещаем текущий предмет из целевого слота в исходный
                 self._place_item_in_slot_direct(current_item_in_target, source_slot_info)

            # Помещаем перетаскиваемый предмет в целевой слот
            if target_type == 'hotbar':
                self.hotbar_slots[target_index] = item
            elif target_type == 'inventory':
                self.inventory[target_row][target_col] = item

            # print(f"Предметы успешно обменены между {source_slot_info} и {target_slot_info}.") # Отладочный принт
            return True # Обмен считается успешным

        # TODO: Добавить логику стакания предметов (если предметы стакуемые и одного типа)

    def _remove_item_from_slot(self, slot_info):
        """Вспомогательный метод для удаления предмета из слота."""
        slot_type = slot_info[0]
        if slot_type == 'hotbar':
            index = slot_info[1]
            if 0 <= index < len(self.hotbar_slots):
                self.hotbar_slots[index] = None
                # print(f"Предмет удален из хотбар слота {index}.") # Отладочный принт
            # else:
                # print(f"Ошибка удаления: Неверный индекс хотбар слота {index}") # Отладочный принт

        elif slot_type == 'inventory':
            row, col = slot_info[1], slot_info[2]
            if 0 <= row < self.inventory_rows and 0 <= col < self.inventory_cols:
                 self.inventory[row][col] = None
                 # print(f"Предмет удален из инвентарь слота ({row}, {col}).") # Отладочный принт
            # else:
                # print(f"Ошибка удаления: Неверные координаты инвентарь слота ({row}, {col})") # Отладочный принт

    def _place_item_in_slot_direct(self, item, slot_info):
        """Вспомогательный метод для прямого помещения предмета в слот (без проверок)."""
        if not item:
            # print("Попытка напрямую поместить None.") # Отладочный принт
            return

        slot_type = slot_info[0]
        if slot_type == 'hotbar':
            index = slot_info[1]
            if 0 <= index < len(self.hotbar_slots):
                self.hotbar_slots[index] = item
                # print(f"Предмет {item.name} напрямую помещен в хотбар слот {index}.") # Отладочный принт
            # else:
                # print(f"Ошибка прямого размещения: Неверный индекс хотбар слота {index}") # Отладочный принт

        elif slot_type == 'inventory':
            row, col = slot_info[1], slot_info[2]
            if 0 <= row < self.inventory_rows and 0 <= col < self.inventory_cols:
                 self.inventory[row][col] = item
                 # print(f"Предмет {item.name} напрямую помещен в инвентарь слот ({row}, {col}).") # Отладочный принт
            # else:
                # print(f"Ошибка прямого размещения: Неверные координаты инвентаря слота ({row}, {col})") # Отладочный принт



    def remove_item_from_inventory(self, item_to_remove, quantity=1):
        # Сначала проверяем хотбар
        for i, item in enumerate(self.hotbar_slots):
            if item and item.name == item_to_remove.name:
                if item.stackable:
                    if item.quantity > quantity:
                        item.quantity -= quantity
                        return True
                    elif item.quantity == quantity:
                        self.hotbar_slots[i] = None
                        return True
                else:
                    self.hotbar_slots[i] = None
                    return True

        # Затем основной инвентарь
        for r in range(self.inventory_rows):
            for c in range(self.inventory_cols):
                item = self.inventory[r][c]
                if item and item.name == item_to_remove.name:
                    if item.stackable:
                        if item.quantity > quantity:
                            item.quantity -= quantity
                            return True
                        elif item.quantity == quantity:
                            self.inventory[r][c] = None
                            return True
                    else:
                        self.inventory[r][c] = None
                        return True
        return False


    def draw(self, screen):
        """Отрисовка инвентаря и хотбара"""

        # Отрисовка панели хотбара
        panel_width = len(self.hotbar_slots) * (self.hotbar_slot_size + self.hotbar_slot_padding) + self.hotbar_panel_padding
        panel_height = self.hotbar_slot_size + 2 * self.hotbar_panel_padding
        panel_x = (screen.get_width() - panel_width) // 2
        panel_y = screen.get_height() - panel_height - 10

        pygame.draw.rect(screen, (50, 50, 50), (panel_x, panel_y, panel_width, panel_height), border_radius=10)

        for index, item in enumerate(self.hotbar_slots):
            slot_x = panel_x + self.hotbar_panel_padding + index * (self.hotbar_slot_size + self.hotbar_slot_padding)
            slot_y = panel_y + self.hotbar_panel_padding

            # Отрисовка рамки выбранного слота
            if index == self.selected_item_index:
                # Увеличиваем размер рамки и сдвигаем ее для центрирования вокруг слота
                border_size = 3 # Толщина рамки
                border_offset = 5 # Отступ рамки от слота
                pygame.draw.rect(screen, (255, 215, 0),
                                 (slot_x - border_offset, slot_y - border_offset,
                                  self.hotbar_slot_size + 2 * border_offset, self.hotbar_slot_size + 2 * border_offset),
                                 border_size, border_radius=10)


            # Отрисовка фона слота
            pygame.draw.rect(screen, (100, 100, 100), (slot_x, slot_y, self.hotbar_slot_size, self.hotbar_slot_size), border_radius=5)

            # Отрисовка предмета в слоте (если он не перетаскивается)
            if item and item is not self.dragging_item:
                self._draw_item_in_slot(screen, item, slot_x, slot_y, self.hotbar_slot_size, item_slot_size=40) # item_slot_size из вашей отрисовки

        # --- Отрисовка инвентаря (если открыт) ---
        if self.inventory_open: # Проверяем флаг inventory_open перед отрисовкой основного инвентаря

            inventory_width = self.inventory_cols * (self.inventory_slot_size + self.inventory_slot_padding) + self.inventory_panel_padding
            inventory_height = self.inventory_rows * (self.inventory_slot_size + self.inventory_slot_padding) + self.inventory_panel_padding
            inventory_x = (screen.get_width() - inventory_width) // 2
            inventory_y = (screen.get_height() - inventory_height) // 2 # Позиция по Y для центрирования инвентаря

            pygame.draw.rect(screen, (50, 50, 50), (inventory_x, inventory_y, inventory_width, inventory_height), border_radius=10)

            for row in range(self.inventory_rows):
                for col in range(self.inventory_cols):
                    slot_x = inventory_x + self.inventory_panel_padding + col * (self.inventory_slot_size + self.inventory_slot_padding)
                    slot_y = inventory_y + self.inventory_panel_padding + row * (self.inventory_slot_size + self.inventory_slot_padding)

                    # Отрисовка фона слота инвентаря
                    pygame.draw.rect(screen, (100, 100, 100), (slot_x, slot_y, self.inventory_slot_size, self.inventory_slot_size), border_radius=5)

                    item = self.inventory[row][col]

                    # Отрисовка предмета в слоте (если он не перетаскивается)
                    if item and item is not self.dragging_item:
                        self._draw_item_in_slot(screen, item, slot_x, slot_y, self.inventory_slot_size, item_slot_size=50) # item_slot_size из вашей отрисовки
        # --- Конец отрисовки инвентаря ---


        # Отрисовка перетаскиваемого предмета (всегда поверх всего)
        if self.dragging_item and self.dragging_item.image:
            mouse_x, mouse_y = pygame.mouse.get_pos()
            # Вычисляем позицию для отрисовки перетаскиваемого предмета с учетом смещения
            draw_x = mouse_x - self.drag_offset[0]
            draw_y = mouse_y - self.drag_offset[1]

            # Масштабируем изображение предмета для перетаскивания (используем размер инвентарного слота для единообразия)
            item_image = self.dragging_item.image
            img_width, img_height = item_image.get_size()
            drag_size = 50 # Размер для перетаскивания (можно сделать настраиваемым)
            scale_factor = min(drag_size / img_width, drag_size / img_height)
            scaled_width = int(img_width * scale_factor)
            scaled_height = int(img_height * scale_factor)

            # Масштабируем изображение
            scaled_image = pygame.transform.scale(item_image, (scaled_width, scaled_height))

            screen.blit(scaled_image, (draw_x, draw_y))

    def _draw_item_in_slot(self, screen, item, slot_x, slot_y, slot_size, item_slot_size):
        """Вспомогательный метод для отрисовки предмета внутри слота."""
        if isinstance(item, Item) and hasattr(item, 'image') and item.image:
            item_image = item.image
            img_width, img_height = item_image.get_size()
            scale_factor = min(item_slot_size / img_width, item_slot_size / img_height)
            scaled_width = int(img_width * scale_factor)
            scaled_height = int(img_height * scale_factor)

            scaled_image = pygame.transform.scale(item_image, (scaled_width, scaled_height))

            img_x = slot_x + (slot_size - scaled_width) // 2
            img_y = slot_y + (slot_size - scaled_height) // 2

            screen.blit(scaled_image, (img_x, img_y))

            # Отображаем количество, если предмет стакается и количество > 1
            if item.stackable and item.quantity > 1:
                quantity_text = self.game_manager.fonts['small'].render(str(item.quantity), True, (255, 255, 255))
                text_rect = quantity_text.get_rect(bottomright=(slot_x + slot_size - 5, slot_y + slot_size - 5))
                screen.blit(quantity_text, text_rect)

    def remove_item_from_inventory(self, item_to_remove, quantity=1):
        """
        Удаляет указанное количество предмета из инвентаря или хотбара.
        Возвращает True, если удаление успешно, False в противном случае.
        """
        removed_count = 0
        # Сначала пытаемся удалить из хотбара
        for i in range(len(self.hotbar_slots)):
            current_item = self.hotbar_slots[i]
            if current_item and current_item.name == item_to_remove.name:
                # В упрощенном варианте просто обнуляем слот
                self.hotbar_slots[i] = None
                removed_count += 1
                print(f"Удален 1 {item_to_remove.name} из хотбара.")
                if removed_count >= quantity:
                    return True  # Успешно удалили нужное количество
        # Если нужно удалить больше, чем есть в хотбаре, ищем в основном инвентаре
        # В текущей простой реализации инвентаря это может быть сложно.
        # В более продвинутой системе инвентаря нужно будет учитывать стаки предметов.
        # В текущей структуре, где каждый слот - отдельный предмет,
        # просто ищем и удаляем нужное количество экземпляров.
        if removed_count < quantity:
            print(
                f"Нужно удалить еще {quantity - removed_count} {item_to_remove.name} из основного инвентаря (пока не реализовано).")
            # TODO: Реализовать поиск и удаление из основного инвентаря
            # Простая заглушка: если удалили из хотбара, считаем успешным.
            # Если не удалили из хотбара, но нужно удалить, это ошибка в этой реализации.
            if removed_count > 0:
                return True  # Если что-то удалили из хотбара, считаем успешным для данного запроса
            else:
                print(f"Не удалось найти {item_to_remove.name} в инвентаре для удаления.")
                return False  # Не найдено предмета для удаления
        return removed_count >= quantity  # Возвращаем True, если удалили нужное количество


==================== item.py ====================

import pygame

class Item(pygame.sprite.Sprite):
    def __init__(self, name, image, item_type, stackable=False, max_stack=1):
        super().__init__()
        self.name = name
        self.image = image
        self.rect = self.image.get_rect()
        self.type = item_type
        self.stackable = stackable  # Можно ли стакать предмет
        self.max_stack = max_stack  # Максимальное количество в стаке
        self.quantity = 1  # Текущее количество в стаке

    def use(self, target):
        pass  # Реализуем в подклассах

class Tool(Item):
    def __init__(self, name, image, tool_type, durability=100):
        # Инструменты не стакаются
        super().__init__(name, image, tool_type, stackable=False, max_stack=1)
        self.durability = durability
        self.max_durability = durability

class Seed(Item):
    def __init__(self, name, image, plant_type):
        # Семена стакаются (например, до 20 штук)
        super().__init__(name, image, 'seed', stackable=True, max_stack=20)
        self.plant_type = plant_type

    def plant(self, location):
        # Метод для посадки семени. Пока просто заглушка.
        print(f"Посажено семя {self.name} в {location}")
        pass


==================== map_renderer.py ====================

import pygame
from src.tilemap import TiledMap


class MapRenderer:
    def __init__(self):
        self.tilemap = None

    def load_map(self, map_path):
        """Загрузка карты"""
        try:
            self.tilemap = TiledMap(map_path)
            return True
        except Exception as e:
            print(f"Ошибка загрузки карты: {e}")
            return False

    def draw_map(self, screen, camera):
        """Отрисовка карты с учетом камеры"""
        if self.tilemap:
            screen.fill((0, 0, 0))  # Очистка экрана
            self.tilemap.draw(screen, camera)



==================== plant.py ====================

import pygame
import os

class Plant(pygame.sprite.Sprite):
    def __init__(self, game_manager, plant_type, tile_x, tile_y):
        super().__init__()
        self.game = game_manager # Ссылка на GameManager
        self.plant_type = plant_type # Тип растения ('cucumber', 'tomato', 'potato')
        self.tile_x = tile_x     # Координаты тайла, на котором растет растение
        self.tile_y = tile_y

        # Стадии роста и связанные с ними спрайты
        # В будущем это можно вынести в отдельный файл конфигурации
        self.growth_stages_sprites = self.load_growth_sprites(plant_type)
        self.current_stage = 0 # Начальная стадия роста (например, 0 - только что посажено)
        self.max_stage = len(self.growth_stages_sprites) - 1 # Максимальная стадия (урожай готов)

        self.image = self.growth_stages_sprites[self.current_stage]
        # Устанавливаем позицию спрайта растения по центру тайла
        # Нужно будет учесть смещение камеры при отрисовке
        tile_size = self.game.tmx_data.tilewidth # Предполагается доступ к tmx_data через game_manager
        tile_center_x = self.tile_x * tile_size + tile_size // 2
        tile_center_y = self.tile_y * tile_size + tile_size // 2
        self.rect = self.image.get_rect(center=(tile_center_x, tile_center_y))

        # Время, связанное с ростом
        self.growth_timer = 0 # Таймер для перехода к следующей стадии
        self.time_to_next_stage = 10 # Время в секундах до перехода к следующей стадии (для примера)

        self.is_watered = False # Флаг, полито ли растение (для будущей механики полива)
        self.ready_to_harvest = False # Флаг, готово ли к сбору урожая

        print(f"Создано растение: {self.plant_type} на тайле ({self.tile_x}, {self.tile_y})")


    def load_growth_sprites(self, plant_type):
        """Загружает спрайты стадий роста для данного типа растения."""
        sprites = []
        # Путь к спрайтам растений
        plant_sprites_dir = os.path.join("sprites", "plants", plant_type)
        # Предполагаем, что спрайты названы stage_0.png, stage_1.png, ..., stage_4.png
        num_stages = 5 # Количество стадий роста
        if not os.path.exists(plant_sprites_dir):
             print(f"Ошибка: Папка со спрайтами для растения '{plant_type}' не найдена: {plant_sprites_dir}")
             # В случае ошибки загрузки, добавим заглушку для каждой стадии
             dummy = pygame.Surface((32, 32), pygame.SRCALPHA)
             dummy.fill((255, 0, 0, 150)) # Полупрозрачный красный
             return [dummy] * num_stages # Возвращаем список заглушек
        for stage_index in range(num_stages):
            sprite_path = os.path.join(plant_sprites_dir, f"stage_{stage_index}.png")
            if os.path.exists(sprite_path):
                try:
                    sprite = pygame.image.load(sprite_path).convert_alpha()
                    # Опционально: масштабирование спрайта под размер тайла
                    # Если тебе нужно масштабировать, раскомментируй и настрой этот блок:
                    if hasattr(self.game, 'tmx_data') and self.game.tmx_data:
                          tile_size = self.game.tmx_data.tilewidth
                          if sprite.get_size() != (tile_size, tile_size):
                              sprite = pygame.transform.scale(sprite, (tile_size, tile_size))
                    sprites.append(sprite)
                except pygame.error as e:
                    print(f"Ошибка загрузки спрайта {sprite_path}: {e}")
                    # Добавляем заглушку в случае ошибки загрузки конкретного файла
                    dummy = pygame.Surface((32, 32), pygame.SRCALPHA)
                    dummy.fill((100, 100, 100, 100)) # Полупрозрачный серый
                    sprites.append(dummy)
            else:
                print(f"Предупреждение: Файл спрайта не найден: {sprite_path}. Добавляется заглушка.")
                # Добавляем заглушку, если файл спрайта отсутствует
                dummy = pygame.Surface((32, 32), pygame.SRCALPHA)
                dummy.fill((100, 100, 100, 100)) # Полупрозрачный серый
                sprites.append(dummy)
        if not sprites:
            print(f"Предупреждение: Не загружено ни одного спрайта для растения типа '{plant_type}'. Возвращается одна заглушка.")
            # Если по какой-то причине список спрайтов пуст, возвращаем хотя бы одну заглушку
            dummy = pygame.Surface((32, 32), pygame.SRCALPHA)
            dummy.fill((255, 0, 0, 100)) # Полупрозрачный красный
            return [dummy]
        # Устанавливаем максимальную стадию на основе количества загруженных спрайтов
        self.max_stage = len(sprites) - 1
        print(f"Для растения '{plant_type}' загружено {len(sprites)} стадий роста. Максимальная стадия: {self.max_stage}")
        return sprites

    def update(self, dt):
        """Обновление состояния растения (рост)."""
        # Логика роста будет здесь
        # Пока простая заглушка: растение растет со временем
        if not self.ready_to_harvest:
            self.growth_timer += dt
            if self.growth_timer >= self.time_to_next_stage:
                self.growth_timer = 0
                self.grow() # Переход к следующей стадии роста

    def grow(self):
        """Переход к следующей стадии роста."""
        if self.current_stage < self.max_stage:
            self.current_stage += 1
            self.image = self.growth_stages_sprites[self.current_stage]
            print(f"Растение {self.plant_type} на ({self.tile_x}, {self.tile_y}) перешло в стадию {self.current_stage}")

            if self.current_stage == self.max_stage:
                self.ready_to_harvest = True
                print(f"Растение {self.plant_type} на ({self.tile_x}, {self.tile_y}) готово к сбору урожая!")


    def water(self):
        """Поливает растение."""
        # Пока заглушка, в будущем может влиять на скорость роста
        self.is_watered = True
        print(f"Растение {self.plant_type} на ({self.tile_x}, {self.tile_y}) полито.")

    def harvest(self):
        """Собирает урожай с растения."""
        if self.ready_to_harvest:
            print(f"Урожай с растения {self.plant_type} на ({self.tile_x}, {self.tile_y}) собран.")
            # TODO: Добавить логику получения предметов урожая игроком
            # TODO: Удалить объект растения с карты
            return True # Урожай собран успешно
        else:
            print(f"Растение {self.plant_type} на ({self.tile_x}, {tile_y}) еще не готово к сбору урожая.")
            return False # Не готово к сбору



==================== player.py ====================

import pygame
import pytmx
import os
from src.item import Tool, Item, Seed # Убедитесь, что импорт Tool и Item корректен
from src.game_state import GameState # Импортируем GameState, если он используется в Player
from src.plant import Plant

class Player(pygame.sprite.Sprite):
    def __init__(self, game_manager, x, y, speed=100):
        super().__init__()
        self.coins = 1000
        self.game = game_manager # Ссылка на GameManager

        # Пути к спрайтам
        self.sprite_path = "sprites/player/sprites" # Путь к основным спрайтам движения

        # Загрузка и организация спрайтов
        self.animations = self.load_animations()

        # Начальное положение и скорость
        self.x = float(x)
        self.y = float(y)
        self.speed = speed

        # Анимационные переменные
        self.direction = "down"  # Начальное направление
        self.moving = False
        self.current_frame = 0
        # Уменьшаем скорость анимации движения (например, до 6 FPS). Настройте по вкусу.
        self.animation_speed = 6
        self.animation_timer = 0

        # Переменные для анимации использования инструмента (взмаха)
        self.is_using_tool = False
        self.tool_use_animation_timer = 0
        # Уменьшаем скорость анимации взмаха (например, до 8 FPS). Настройте по вкусу.
        self.tool_use_animation_speed = 8
        self.tool_use_current_frame = 0
        self.current_tool_animation_type = None # Тип текущей анимации инструмента (например, 'hoe_swing')

        # Установка начального изображения и прямоугольника
        if self.direction in self.animations and self.animations[self.direction]:
             self.image = self.animations[self.direction][0]
        else:
             print(f"Предупреждение: Начальная анимация для направления '{self.direction}' пуста или не существует. Используется заглушка.")
             dummy = pygame.Surface((16, 16))
             dummy.fill((0, 255, 0))
             self.image = dummy

        self.rect = self.image.get_rect(topleft=(x, y))

        # Создаем отдельный прямоугольник для коллизий
        self.collision_rect = pygame.Rect(0, 0, 10, 10) # Размер коллизии (настройте по необходимости)
        self.update_collision_rect()  # Обновляем позицию коллизии

        print(f"Игрок создан на позиции ({x}, {y}) со скоростью {speed}")


    def add_coins(self, amount):
        self.coins += amount
    

    def remove_coins(self, amount):
        if self.coins >= amount:
            self.coins -= amount
        else:
            print("Недостаточно монет!")


    def draw_coins(self, screen):
        font = self.game.fonts['small']
        text = font.render(f"Coins: {self.coins}", True, (255, 255, 255))
        screen.blit(text, (5, 35,5,5))

    def add_item_to_inventory(self, item, slot_index=None):
        """Добавляет предмет в инвентарь или хотбар"""
        if slot_index is not None and 0 <= slot_index < len(self.hotbar_slots):
            # Добавляем в хотбар
            self.hotbar_slots[slot_index] = item
            return True
        elif self._find_empty_slot():
            # Добавляем в основной инвентарь
            row, col = self._find_empty_slot()
            self.inventory[row][col] = item
            return True
        else:
            print("Инвентарь полон!")
            return False

    def _find_empty_slot(self):
        """Ищет первый пустой слот в инвентаре"""
        for row in range(len(self.inventory)):
            for col in range(len(self.inventory[row])):
                if self.inventory[row][col] is None:
                    return row, col
        return None

    def load_animations(self):
        """Загрузка всех анимаций игрока"""
        animations = {
            "down": [],
            "left": [],
            "right": [],
            "up": [],
            "hoe_swing": [], # Анимация для взмаха мотыгой
            # Добавьте другие анимации инструментов здесь
        }

        # --- Загрузка основных анимаций движения ---
        self.sprite_path = "sprites/player/sprites"
        if not os.path.exists(self.sprite_path):
            print(f"Ошибка: Путь {self.sprite_path} для основных анимаций не существует.")
            dummy = pygame.Surface((16, 16))
            dummy.fill((0, 255, 0))
            for direction in ["down", "left", "right", "up"]:
                animations[direction] = [dummy]
        else:
            try:
                # Здесь должна быть ваша логика загрузки спрайтов движения
                # Пример для спрайт-листа 4x4 (16 спрайтов)
                directions_map = {
                    "down": [0, 1, 2, 3],
                    "left": [8, 9, 10, 11],
                    "right": [12, 13, 14, 15],
                    "up": [4, 5, 6, 7],
                }
                sprites = []
                for i in range(16): # Измените диапазон, если у вас другое количество спрайтов
                    img_path = os.path.join(self.sprite_path, f"sprite_{i}.png")
                    if os.path.exists(img_path):
                        sprite = pygame.image.load(img_path).convert_alpha()
                        # sprite = pygame.transform.scale(sprite, (70, 92)) # Пример масштабирования
                        sprites.append(sprite)
                    else:
                        print(f"Предупреждение: Файл {img_path} не найден для основной анимации.")
                        dummy = pygame.Surface((16, 16))
                        dummy.fill((255, 0, 255))
                        sprites.append(dummy)

                for direction, indices in directions_map.items():
                    for idx in indices:
                        if idx < len(sprites):
                            animations[direction].append(sprites[idx])
                        else:
                             print(f"Предупреждение: Индекс спрайта {idx} вне диапазона для направления {direction}.")
            except Exception as e:
                print(f"Ошибка при загрузке основных спрайтов: {e}")
                dummy = pygame.Surface((32, 32))
                dummy.fill((0, 255, 0))
                for direction in ["down", "left", "right", "up"]:
                    animations[direction] = [dummy]

        # --- Загрузка анимации взмаха мотыгой ---
        hoe_swing_sprites_dir = os.path.join("sprites", "player", "sprites_tools", "hoe_swing")
        hoe_swing_files = ["frame_0.png", "frame_1.png"] # Убедитесь, что имена файлов соответствуют

        if os.path.exists(hoe_swing_sprites_dir):
            try:
                loaded_frames = 0
                for filename in hoe_swing_files:
                    img_path = os.path.join(hoe_swing_sprites_dir, filename)
                    if os.path.exists(img_path):
                        sprite = pygame.image.load(img_path).convert_alpha()
                        # Масштабируйте, если нужно, до размера игрока
                        # sprite = pygame.transform.scale(sprite, (70, 92))
                        animations["hoe_swing"].append(sprite)
                        loaded_frames += 1
                    else:
                        print(f"Предупреждение: Файл {img_path} не найден для анимации взмаха мотыгой. Проверьте имя файла.")

                if loaded_frames == 0:
                    print(f"Предупреждение: Не загружено ни одного кадра для анимации взмаха мотыгой из {hoe_swing_sprites_dir}. Проверьте имена файлов ({', '.join(hoe_swing_files)}).")
                    if animations["down"]:
                         animations["hoe_swing"] = [animations["down"][0]]
                    else:
                         dummy = pygame.Surface((32, 32))
                         dummy.fill((255, 0, 255))
                         animations["hoe_swing"] = [dummy]
            except Exception as e:
                print(f"Ошибка при загрузке анимации взмаха мотыгой из {hoe_swing_sprites_dir}: {e}")
                if animations["down"]:
                     animations["hoe_swing"] = [animations["down"][0]]
                else:
                     dummy = pygame.Surface((32, 32))
                     dummy.fill((255, 0, 255))
                     animations["hoe_swing"] = [dummy]
        else:
            print(f"Предупреждение: Папка анимации взмаха мотыгой не найдена: {hoe_swing_sprites_dir}")
            if animations["down"]:
                 animations["hoe_swing"] = [animations["down"][0]]
            else:
                 dummy = pygame.Surface((32, 32))
                 dummy.fill((255, 0, 255))
                 animations["hoe_swing"] = [dummy]

        print(f"Загружено {len(animations['hoe_swing'])} кадров для анимации взмаха мотыгой.")
        return animations

    # --- Добавлен метод handle_input для обработки событий, специфичных для игрока ---
    def handle_input(self, event):
        """Обработка событий ввода, специфичных для игрока (использование предметов)."""
        # Обрабатываем ввод игрока только если игра в состоянии Game, не на паузе
        # и инвентарь НЕ открыт (так как клики мышью идут на инвентарь)
        if self.game.state == GameState.GAME and not self.game.paused and not self.game.inventory_manager.inventory_open:
            if event.type == pygame.MOUSEBUTTONDOWN:
                if event.button == 1:  # Левая кнопка мыши
                    # Получаем выбранный предмет из хотбара через InventoryManager
                    selected_item_index = self.game.inventory_manager.selected_item_index
                    # Проверяем, что индекс корректен
                    if 0 <= selected_item_index < len(self.game.inventory_manager.hotbar_slots):
                        selected_item = self.game.inventory_manager.hotbar_slots[selected_item_index]
                        # --- Проверяем, является ли предмет инструментом (например, мотыгой) ---
                        if selected_item and isinstance(selected_item, Tool): # Используем isinstance(selected_item, Tool)
                             if selected_item.type == 'hoe' and not self.is_using_tool:
                                 self.use_tool() # Вызываем метод использования инструмента
                             # TODO: Добавить проверки для других типов инструментов (топор, лейка и т.д.)
                             # elif selected_item.type == 'axe' and not self.is_using_tool:
                             #     self.use_tool() # Запускаем анимацию топора
                             # elif selected_item.type == 'wateringcan' and not self.is_using_tool:
                             #     self.use_tool() # Запускаем анимацию лейки
                             # ...
                        # --- Проверяем, является ли предмет семенем ---
                        elif selected_item and isinstance(selected_item, Seed):
                            target_tile_x, target_tile_y = self.get_tile_in_front()
                            if self.game and hasattr(self.game, 'is_tile_plantable'):
                                if self.game.is_tile_plantable(target_tile_x, target_tile_y):
                                    # Проверяем наличие атрибута plant_type
                                    if hasattr(selected_item, 'plant_type'):
                                        # Уменьшаем количество семян
                                        selected_item.quantity -= 1
                                        if selected_item.quantity <= 0:
                                            # Удаляем предмет из инвентаря, если закончился
                                            self.game.inventory_manager.hotbar_slots[self.game.inventory_manager.selected_item_index] = None
                                        
                                        # Создаем новое растение
                                        new_plant = Plant(self.game, selected_item.plant_type, target_tile_x, target_tile_y)
                                        
                                        # Добавляем растение в группы спрайтов
                                        if hasattr(self.game, 'all_sprites') and hasattr(self.game, 'plants'):
                                            self.game.all_sprites.add(new_plant)
                                            self.game.plants.add(new_plant)
                                            print(f"Объект растения {new_plant.plant_type} создан и добавлен в группы спрайтов.")
                                        
                                        # Обновляем состояние тайла
                                        self.game.update_tile_state(target_tile_x, target_tile_y, has_plant=new_plant)
                                    else:
                                        print(f"Ошибка: У выбранного семени {selected_item.name} нет атрибута 'plant_type'.")
                                else:
                                    print("На этой земле нельзя сажать.")
                            else:
                                print("Неверные координаты тайла или метод is_tile_plantable не найден в GameManager.")
            # Обработка движения (клавиши get_pressed() обрабатываются в update)
            pass

    def update(self, dt):
        """Обновление игрока (движение и анимация)"""

        # --- Обработка движения (только если игрок не использует инструмент и инвентарь закрыт) ---
        # Логика движения обрабатывается здесь с помощью pygame.key.get_pressed()
        if not self.is_using_tool and not self.game.inventory_manager.inventory_open:

            keys = pygame.key.get_pressed()
            prev_x = self.x
            prev_y = self.y
            was_moving = self.moving # Сохраняем предыдущее состояние движения

            dx = 0
            dy = 0

            if keys[self.game.settings['controls']['left']]: # Используем настройки клавиш из GameManager
                dx = -self.speed * dt
            elif keys[self.game.settings['controls']['right']]:
                dx = self.speed * dt

            if keys[self.game.settings['controls']['up']]:
                dy = -self.speed * dt
            elif keys[self.game.settings['controls']['down']]:
                dy = self.speed * dt

            self.moving = (dx != 0 or dy != 0)

            # Определяем направление
            if self.moving:
                if keys[self.game.settings['controls']['up']]:
                    self.direction = "up"
                elif keys[self.game.settings['controls']['down']]:
                    self.direction = "down"
                elif keys[self.game.settings['controls']['left']]:
                    self.direction = "left"
                elif keys[self.game.settings['controls']['right']]:
                    self.direction = "right"


            # Обновляем позиции и проверяем коллизии
            self.x += dx
            self.rect.x = int(self.x)
            self.update_collision_rect()
            if self.game and hasattr(self.game, 'check_collision'):
                 if self.game.check_collision(self.collision_rect):
                     self.x = prev_x
                     self.rect.x = int(prev_x)
                     self.update_collision_rect()

            self.y += dy
            self.rect.y = int(self.y)
            self.update_collision_rect()
            if self.game and hasattr(self.game, 'check_collision'):
                 if self.game.check_collision(self.collision_rect):
                     self.y = prev_y
                     self.rect.y = int(prev_y)
                     self.update_collision_rect()

            # Ограничение движения игрока границами карты
            if hasattr(self.game, "tmx_data") and self.game.map_loaded:
                map_width = self.game.tmx_data.width * self.game.tmx_data.tilewidth
                map_height = self.game.tmx_data.height * self.game.tmx_data.tileheight
                self.x = max(0.0, min(self.x, float(map_width - self.rect.width)))
                self.y = max(0.0, min(self.y, float(map_height - self.rect.height)))
                self.rect.x = int(self.x)
                self.rect.y = int(self.y)
                self.update_collision_rect()

            # Обновление анимации движения
            self.update_animation(dt, was_moving)

        elif self.is_using_tool: # Если игрок использует инструмент, обновляем только анимацию инструмента
             self.update_tool_use_animation(dt)
        # else: # Если инвентарь открыт или игра на паузе, анимация движения не обновляется
            # was_moving = self.moving # Сохраняем предыдущее состояние движения
            # self.moving = False # Игрок не движется, если инвентарь открыт или пауза
            # self.update_animation(dt, was_moving) # Обновляем анимацию, чтобы перейти в idle

    def update_collision_rect(self):
        """Обновляет позицию прямоугольника коллизии."""
        self.collision_rect.center = (self.rect.center[0], self.rect.center[1]+7)

    def update_animation(self, dt, was_moving):
        """Обновление анимации игрока (движения)"""
        if self.is_using_tool: # Если используется инструмент, не обновляем анимацию движения
            return

        if self.direction not in self.animations or not self.animations[self.direction]:
            print(f"Предупреждение: Анимация для направления '{self.direction}' пуста или не существует. Используется Fallback.")
            if "down" in self.animations and self.animations["down"]:
                 self.image = self.animations["down"][0]
            else:
                 dummy = pygame.Surface((32, 32))
                 dummy.fill((0, 255, 0))
                 self.image = dummy
            return

        if was_moving != self.moving:
            self.current_frame = 0
            self.animation_timer = 0

        if self.moving:
            self.animation_timer += dt
            if self.animation_timer >= 1.0 / self.animation_speed:
                self.animation_timer = 0
                self.current_frame = (self.current_frame + 1) % len(self.animations[self.direction])
        else:
            self.current_frame = 0 # Используем первый кадр (idle) при остановке

        self.image = self.animations[self.direction][self.current_frame]

    def update_tool_use_animation(self, dt):
        """Обновление анимации использования инструмента и вызов действия в нужный момент."""
        # Проверяем, что текущая анимация инструмента существует и не пуста
        if self.current_tool_animation_type and \
           self.current_tool_animation_type in self.animations and \
           self.animations[self.current_tool_animation_type]:

            self.tool_use_animation_timer += dt

            # Проигрываем анимацию взмаха
            if self.tool_use_animation_timer >= 1.0 / self.tool_use_animation_speed:
                self.tool_use_animation_timer = 0
                prev_frame = self.tool_use_current_frame # Сохраняем предыдущий кадр
                self.tool_use_current_frame += 1

                # Проверяем, закончилась ли анимация
                if self.tool_use_current_frame >= len(self.animations[self.current_tool_animation_type]):
                    self.is_using_tool = False # Сбрасываем флаг использования инструмента
                    self.tool_use_current_frame = 0 # Сбрасываем кадр анимации инструмента
                    self.current_tool_animation_type = None # Сбрасываем тип анимации инструмента

                    # После завершения анимации инструмента, возвращаемся к idle-анимации по текущему направлению
                    if self.direction in self.animations and self.animations[self.direction]:
                         self.image = self.animations[self.direction][0]
                    else:
                         dummy = pygame.Surface((32, 32))
                         dummy.fill((0, 255, 0))
                         self.image = dummy

                else:
                    # Проигрываем следующий кадр анимации инструмента
                    self.image = self.animations[self.current_tool_animation_type][self.tool_use_current_frame]

                # --- Вызов действия инструмента в определенный момент анимации ---
                # Вызываем till_tile только один раз при переходе на нужный кадр
                if self.current_tool_animation_type == 'hoe_swing':
                    # Например, вызов till_tile на втором кадре анимации взмаха (индекс 1)
                    if prev_frame == 0 and self.tool_use_current_frame == 1: # Вызываем при переходе от кадра 0 к 1
                         target_tile_x, target_tile_y = self.get_tile_in_front()
                         if self.game and hasattr(self.game, 'till_tile') and (target_tile_x != -1 or target_tile_y != -1):
                              self.game.till_tile(target_tile_x, target_tile_y)
                         # else:
                             # print("Не удалось определить координаты тайла перед игроком или GameManager не имеет till_tile.") # Отладочный принт

                # TODO: Добавить вызовы действий для других инструментов в соответствующие моменты анимации
                # elif self.current_tool_animation_type == 'axe_swing':
                #     if prev_frame == X and self.tool_use_current_frame == Y:
                #         self.game.cut_tree(...) # Вызов функции рубки дерева
                # elif self.current_tool_animation_type == 'watering_can':
                #     if prev_frame == X and self.tool_use_current_frame == Y:
                #         self.game.water_tile(...) # Вызов функции полива

        else:
            # Если нет текущей анимации инструмента или она пуста, сбрасываем флаг использования инструмента
            self.is_using_tool = False
            self.tool_use_current_frame = 0
            self.current_tool_animation_type = None
            # Возвращаемся к idle-анимации движения
            if self.direction in self.animations and self.animations[self.direction]:
                 self.image = self.animations[self.direction][0]
            else:
                 dummy = pygame.Surface((32, 32))
                 dummy.fill((0, 255, 0))
                 self.image = dummy

    def use_tool(self):
        """Запускает анимацию использования текущего выбранного инструмента."""
        # Получаем выбранный предмет из хотбара через InventoryManager
        if self.game is None or not hasattr(self.game, 'inventory_manager'):
             print("Ошибка в use_tool: Нет доступа к InventoryManager в GameManager.")
             return

        inventory_manager = self.game.inventory_manager
        selected_item_index = inventory_manager.selected_item_index

        if not (0 <= selected_item_index < len(inventory_manager.hotbar_slots)):
            # print("Неверный индекс выбранного слота хотбара.") # Отладочный принт
            return

        selected_item = inventory_manager.hotbar_slots[selected_item_index]

        if selected_item and isinstance(selected_item, Tool):
            if selected_item.type == 'hoe':
                self.is_using_tool = True
                self.tool_use_animation_timer = 0
                self.tool_use_current_frame = 0
                self.current_tool_animation_type = 'hoe_swing'
                # Логика вызова till_tile ПЕРЕНЕСЕНА в update_tool_use_animation!
            # TODO: Добавить запуск анимаций для других инструментов
            # elif selected_item.type == 'axe':
            #     self.is_using_tool = True
            #     self.tool_use_animation_timer = 0
            #     self.tool_use_current_frame = 0
            #     self.current_tool_animation_type = 'axe_swing'
            # ...
        # else:
            # print("В выбранном слоте нет инструмента или предмет не является инструментом.") # Отладочный принт

    def get_tile_in_front(self):
        """Определяет координаты клетки на карте, которая находится перед игроком."""
        if not self.game or not hasattr(self.game, 'tmx_data') or not self.game.map_loaded:
             print("Ошибка в get_tile_in_front: Нет доступа к tmx_data в GameManager или карта не загружена.")
             return -1, -1

        tile_size = self.game.tmx_data.tilewidth

        player_center_x = self.collision_rect.centerx
        player_center_y = self.collision_rect.centery

        offset_x, offset_y = 0, 0
        pixel_offset = tile_size // 2

        if self.direction == "right":
            offset_x = pixel_offset
        elif self.direction == "left":
            offset_x = -pixel_offset
        elif self.direction == "down":
            offset_y = pixel_offset
        elif self.direction == "up":
            offset_y = -pixel_offset

        target_center_x = player_center_x + offset_x
        target_center_y = player_center_y + offset_y

        target_tile_x = int(target_center_x // tile_size)
        target_tile_y = int(target_center_y // tile_size)

        map_width_tiles = self.game.tmx_data.width
        map_height_tiles = self.game.tmx_data.height

        target_tile_x = max(0, min(target_tile_x, map_width_tiles - 1))
        target_tile_y = max(0, min(target_tile_y, map_height_tiles - 1))

        return target_tile_x, target_tile_y


==================== render_manager.py ====================

import pygame
from src.map_renderer import MapRenderer

class RenderManager:
    def __init__(self, screen_manager):
        self.screen_manager = screen_manager
        self.map_renderer = MapRenderer()
        # Загружаем фон один раз при создании меню
        self.background_image = pygame.image.load('p.jpg').convert()
        # Если нужно — масштабируем до размера экрана
        screen = pygame.display.get_surface()  # ИЛИ заранее известный размер
        self.background_image = pygame.transform.scale(self.background_image, (screen.get_width(), screen.get_height()))

        # Инициализация шрифтов
        self.title_font = pygame.font.Font(None, 64)
        self.menu_font = pygame.font.Font(None, 36)
        self.ui_font = pygame.font.Font(None, 24)

        # Цветовая палитра
        self.COLORS = {
            'WHITE': (255, 255, 255),
            'BLACK': (0, 0, 0),
            'GRAY': (128, 128, 128),
            'LIGHT_GRAY': (192, 192, 192),
            'GREEN': (0, 255, 0),
            'RED': (255, 0, 0),
            'BLUE': (0, 0, 255),
            'TRANSPARENT_BLACK': (0, 0, 0, 128),
            'YELLOW': (244,169,0)
        }

        # Размеры кнопок и отступы
        self.BUTTON_SIZE = (200, 50)
        self.BUTTON_SPACING = 20
        self.SLIDER_SIZE = (200, 20)
        self.CHECKBOX_SIZE = (20, 20)

    def draw_menu(self, game_manager):
        """Отрисовка главного меню"""
        screen = self.screen_manager.get_screen()
        # Используем сохраненное изображение
        if hasattr(self, 'background_image'):
            screen.blit(self.background_image, (0, 0))
        else:
            # В случае, если по каким-то причинам не загрузилось, зальем черным
            screen.fill(self.COLORS['BLACK'])

        # Заголовок
        title = self.title_font.render("Ушастая усадьба", True, self.COLORS['YELLOW'])
        title_rect = title.get_rect(center=(screen.get_width() // 2, 100))
        screen.blit(title, title_rect)

        # Кнопки меню
        buttons = ["Начать игру", "Настройки", "Выход"]
        button_y = 250

        for text in buttons:
            button_rect = pygame.Rect(
                (screen.get_width() - self.BUTTON_SIZE[0]) // 2,
                button_y,
                self.BUTTON_SIZE[0],
                self.BUTTON_SIZE[1]
            )

            # Проверка наведения мыши
            mouse_pos = pygame.mouse.get_pos()
            if button_rect.collidepoint(mouse_pos):
                pygame.draw.rect(screen, self.COLORS['GRAY'], button_rect)
                color = self.COLORS['WHITE']
            else:
                pygame.draw.rect(screen, self.COLORS['WHITE'], button_rect, 2)
                color = self.COLORS['WHITE']

            # Текст кнопки
            text_surface = self.menu_font.render(text, True, color)
            text_rect = text_surface.get_rect(center=button_rect.center)
            screen.blit(text_surface, text_rect)

            button_y += self.BUTTON_SIZE[1] + self.BUTTON_SPACING

    def draw_settings(self, game_manager):
        """Отрисовка меню настроек"""
        screen = self.screen_manager.get_screen()
        screen = pygame.display.get_surface()  # ИЛИ заранее известный размер
        self.background_image = pygame.transform.scale(self.background_image, (screen.get_width(), screen.get_height()))
        # Используем сохраненное изображение
        if hasattr(self, 'background_image'):
            screen.blit(self.background_image, (0, 0))
        else:
            # В случае, если по каким-то причинам не загрузилось, зальем черным
            screen.fill(self.COLORS['BLACK'])

        # Заголовок
        title = self.title_font.render("Настройки", True, self.COLORS['WHITE'])
        title_rect = title.get_rect(center=(screen.get_width() // 2, 50))
        screen.blit(title, title_rect)

        # Настройки звука
        self.draw_slider(screen, "Громкость звука", game_manager.settings['sound_volume'], 150)
        self.draw_slider(screen, "Громкость музыки", game_manager.settings['music_volume'], 220)

        # Настройки экрана
        self.draw_checkbox(screen, "Полный экран", game_manager.settings['fullscreen'], 290)

        # Настройки FPS
        self.draw_slider(screen, "Ограничение FPS", game_manager.settings['fps_limit'] / 120, 360)

        # Кнопка "Назад"
        back_rect = pygame.Rect(
            (screen.get_width() - self.BUTTON_SIZE[0]) // 2,
            screen.get_height() - 80,
            self.BUTTON_SIZE[0],
            self.BUTTON_SIZE[1]
        )

        mouse_pos = pygame.mouse.get_pos()
        if back_rect.collidepoint(mouse_pos):
            pygame.draw.rect(screen, self.COLORS['GRAY'], back_rect)
            color = self.COLORS['WHITE']
        else:
            pygame.draw.rect(screen, self.COLORS['WHITE'], back_rect, 2)
            color = self.COLORS['WHITE']

        back_text = self.menu_font.render("Назад", True, color)
        back_text_rect = back_text.get_rect(center=back_rect.center)
        screen.blit(back_text, back_text_rect)

    def draw_game(self, screen, game_manager):
        """Отрисовка игрового экрана"""
        screen.fill((0, 0, 0))  # Заливка экрана черным цветом

        # Отрисовка карты с учетом камеры
        if game_manager.map_loaded:
            # Получаем видимую область
            camera_rect = game_manager.camera.camera

            # Отрисовываем видимые тайлы
            for layer in game_manager.tmx_data.visible_layers:
                if hasattr(layer, 'data'):
                    # Определяем видимую область в тайлах
                    startx = max(0, camera_rect.x // game_manager.tmx_data.tilewidth)
                    starty = max(0, camera_rect.y // game_manager.tmx_data.tileheight)
                    endx = min(game_manager.tmx_data.width,
                               (camera_rect.x + camera_rect.width) // game_manager.tmx_data.tilewidth + 1)
                    endy = min(game_manager.tmx_data.height,
                               (camera_rect.y + camera_rect.height) // game_manager.tmx_data.tileheight + 1)

                    # Отрисовываем только видимые тайлы
                    for x in range(startx, endx):
                        for y in range(starty, endy):
                            gid = layer.data[y][x]
                            if gid:
                                tile = game_manager.tmx_data.get_tile_image_by_gid(gid)
                                if tile:
                                    # Применяем смещение камеры
                                    pos = game_manager.camera.apply_point(
                                        x * game_manager.tmx_data.tilewidth,
                                        y * game_manager.tmx_data.tileheight
                                    )
                                    screen.blit(tile, pos)

        # Отрисовка спрайтов с учетом камеры
        for sprite in game_manager.all_sprites:
            # Применяем камеру к позиции спрайта
            camera_rect = game_manager.camera.apply(sprite)
            screen.blit(sprite.image, camera_rect)

            # Если это игрок, рисуем его имя
            if sprite == game_manager.player:
                # Отрисовка таблички с именем игрока
                name_tag_bg_rect = pygame.Rect(
                    camera_rect.centerx - sprite.name_tag_bg.get_width() // 2,
                    camera_rect.top - sprite.name_tag_bg.get_height() - 5,
                    sprite.name_tag_bg.get_width(),
                    sprite.name_tag_bg.get_height()
                )
                screen.blit(sprite.name_tag_bg, name_tag_bg_rect)

                name_tag_rect = pygame.Rect(
                    camera_rect.centerx - sprite.name_tag.get_width() // 2,
                    camera_rect.top - sprite.name_tag.get_height() - 7,
                    sprite.name_tag.get_width(),
                    sprite.name_tag.get_height()
                )
                screen.blit(sprite.name_tag, name_tag_rect)

    def draw_map(self, screen, game_manager):
        """Отрисовка игровой карты"""
        for layer in game_manager.tmx_data.visible_layers:
            if hasattr(layer, 'data'):
                for x, y, gid in layer:
                    tile = game_manager.tmx_data.get_tile_image_by_gid(gid)
                    if tile:
                        screen.blit(tile, (x * game_manager.tmx_data.tilewidth,
                                           y * game_manager.tmx_data.tileheight))

    def draw_game_ui(self, screen, game_manager):
        """Отрисовка игрового интерфейса"""
        # Отображение FPS
        fps = str(int(game_manager.clock.get_fps()))
        fps_text = self.ui_font.render(f"FPS: {fps}", True, self.COLORS['WHITE'])
        screen.blit(fps_text, (10, 10))

    def draw_slider(self, screen, text, value, y_pos):
        """Отрисовка слайдера настроек"""
        # Текст настройки
        text_surface = self.menu_font.render(text, True, self.COLORS['WHITE'])
        screen.blit(text_surface, (50, y_pos))

        # Слайдер
        slider_rect = pygame.Rect(300, y_pos, self.SLIDER_SIZE[0], self.SLIDER_SIZE[1])
        pygame.draw.rect(screen, self.COLORS['WHITE'], slider_rect, 2)

        # Заполнение слайдера
        fill_rect = pygame.Rect(301, y_pos + 1, (self.SLIDER_SIZE[0] - 2) * value, self.SLIDER_SIZE[1] - 2)
        pygame.draw.rect(screen, self.COLORS['WHITE'], fill_rect)

        # Значение
        value_text = self.menu_font.render(f"{int(value * 100)}%", True, self.COLORS['WHITE'])
        screen.blit(value_text, (520, y_pos))

    def draw_checkbox(self, screen, text, checked, y_pos):
        """Отрисовка чекбокса настроек"""
        # Текст настройки
        text_surface = self.menu_font.render(text, True, self.COLORS['WHITE'])
        screen.blit(text_surface, (50, y_pos))

        # Чекбокс
        checkbox_rect = pygame.Rect(300, y_pos, self.CHECKBOX_SIZE[0], self.CHECKBOX_SIZE[1])
        pygame.draw.rect(screen, self.COLORS['WHITE'], checkbox_rect, 2)

        # Отметка
        if checked:
            inner_rect = pygame.Rect(
                checkbox_rect.x + 4,
                checkbox_rect.y + 4,
                checkbox_rect.width - 8,
                checkbox_rect.height - 8
            )
            pygame.draw.rect(screen, self.COLORS['WHITE'], inner_rect)

    def draw_loading_screen(self, screen, progress=0):
        """Отрисовка экрана загрузки"""
        screen.fill(self.COLORS['BLACK'])

        # Текст загрузки
        loading_text = self.title_font.render("Загрузка...", True, self.COLORS['WHITE'])
        text_rect = loading_text.get_rect(center=(screen.get_width() // 2, screen.get_height() // 2 - 50))
        screen.blit(loading_text, text_rect)

        # Полоса загрузки
        bar_rect = pygame.Rect(
            screen.get_width() // 4,
            screen.get_height() // 2 + 20,
            screen.get_width() // 2,
            20
        )
        pygame.draw.rect(screen, self.COLORS['WHITE'], bar_rect, 2)

        # Заполнение полосы загрузки
        fill_rect = pygame.Rect(
            bar_rect.x + 2,
            bar_rect.y + 2,
            (bar_rect.width - 4) * progress,
            bar_rect.height - 4
        )
        pygame.draw.rect(screen, self.COLORS['WHITE'], fill_rect)

        pygame.display.flip()



==================== resource_loader.py ====================

import os
import pygame
import pytmx


class ResourceLoader:
    @staticmethod
    def load_resources():
        resources = {
            'loaded': False,
            'sprites': {},
            'sounds': {},
            'tilemap': None
        }

        try:
            # Проверяем, существуют ли необходимые файлы
            required_files = ["maps.tmx", "player_action_sprite_heet.png", "gra.tsx"]  # Добавили gra.tsx
            missing_files = [f for f in required_files if not os.path.exists(f)]

            if missing_files:
                print(f"Отсутствуют файлы: {', '.join(missing_files)}")
                return resources

            # Создаем проверку для grass.png, если она требуется
            if not os.path.exists("grass.png") and os.path.exists("gra.tsx"):
                print("Файл grass.png не найден, но найден gra.tsx. Используем его вместо grass.png")
                # Можно сделать симлинк или копию файла, если система ожидает определенное имя
                # Пример: os.symlink("gra.tsx", "grass.png")

            # Загрузка TMX карты с указанием базового пути к тайлсетам
            resources['tilemap'] = pytmx.load_pygame("maps.tmx", pixelalpha=True)

            # Загрузка спрайта игрока
            resources['sprites']['player'] = pygame.image.load("character_move_sprite_sheet.png").convert_alpha()

            resources['loaded'] = True
            return resources

        except Exception as e:
            print(f"Ошибка при загрузке ресурсов: {e}")
            return resources


==================== screen_manager.py ====================

import pygame
from src.settings import WINDOW_SIZE
from src.settings import FULLSCREEN_SIZE

class ScreenManager:
    def __init__(self):
        self.current_mode = 'windowed'
        self.screen = pygame.display.set_mode(WINDOW_SIZE[self.current_mode])
        pygame.display.set_caption("Happy Farm")

    def toggle_screen_mode(self):
        if self.current_mode == 'windowed':
            self.current_mode = 'fullscreen'
            self.screen = pygame.display.set_mode(WINDOW_SIZE['fullscreen'], pygame.FULLSCREEN)
        else:
            self.current_mode = 'windowed'
            self.screen = pygame.display.set_mode(WINDOW_SIZE['windowed'])

    def get_screen(self):
        return self.screen

    def get_center_x(self):
        return WINDOW_SIZE[self.current_mode][0] // 2

    def get_center_y(self):
        return WINDOW_SIZE[self.current_mode][1] // 2

    def get_current_mode(self):
        return self.current_mode



==================== settings.py ====================

import pygame

# Инициализация pygame перед получением информации о дисплее
pygame.init()

# Константы для цветов
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GRAY = (128, 128, 128)
DARK_GRAY = (64, 64, 64)

# Базовое разрешение для оконного режима
DEFAULT_WINDOW_SIZE = (800, 600)

# Получаем размер экрана
screen_info = pygame.display.Info()
FULLSCREEN_SIZE = (screen_info.current_w, screen_info.current_h)

# Настройки экрана
WINDOW_SIZE = {
    'windowed': DEFAULT_WINDOW_SIZE,
    'fullscreen': FULLSCREEN_SIZE
}

# Настройки по умолчанию
settings = {
    'window_mode': 'windowed',  # 'windowed', 'borderless', 'fullscreen'
    'music_volume': 0.7,
    'sound_volume': 0.7,
    'master_volume': 0.7
}


==================== shop.py ====================

# shop.py
import pygame
import os
from src.item import Item, Tool, Seed

class ShopItem:
    """Класс для предметов в магазине"""
    def __init__(self, item, buy_price, sell_price=None):
        self.item = item
        self.buy_price = buy_price
        self.sell_price = sell_price if sell_price else buy_price // 2
        self.quantity = 999  # Бесконечное количество в магазине


class Shop:
    """Класс магазина"""
    def __init__(self, game_manager):
        self.game_manager = game_manager
        self.is_open = False
        self.current_tab = "buy"  # "buy" или "sell"
        self.selected_item_index = 0
        self.scroll_offset = 0
        # Позиция магазина - устанавливаем позицию по умолчанию
        # Позиция будет обновлена после загрузки карты
        self.shop_x, self.shop_y = 1000, 1000
        self.shop_range = 35  # Радиус действия магазина
        self.position_set = False  # Флаг для отслеживания установки позиции
        # Товары магазина
        self.shop_items = self.init_shop_items()
        # UI параметры
        self.font = pygame.font.SysFont('Arial', 20)
        self.small_font = pygame.font.SysFont('Arial', 12)

    def toggle_shop(self):
        """Открывает/закрывает магазин"""
        self.is_open = not self.is_open
        print("Магазин открыт/закрыт")

    def set_position_from_spawn(self):
        """Устанавливает позицию магазина относительно точки спавна"""
        if not self.position_set:
            try:
                self.shop_x, self.shop_y = 500, 1010
                self.position_set = True
                print(f"Позиция магазина установлена: ({self.shop_x}, {self.shop_y})")
            except AttributeError:
                # Карта еще не загружена, используем позицию по умолчанию
                pass

    def init_shop_items(self):
        """Инициализация товаров магазина"""
        items = []
        
        # Добавляем инструменты из game_manager (только для покупки)
        if hasattr(self.game_manager, 'tools') and 'hoe' in self.game_manager.tools:
            items.append(ShopItem(self.game_manager.tools['hoe'], 100, 0))  # sell_price=0 - нельзя продать
        
        # Пути к спрайтам
        item_sprites_seed_path = os.path.join("sprites", "items")
        item_sprites_plants = os.path.join("sprites", "plants", "grownPlants")

        try:
            # Загружаем изображения для семян (только для покупки)
            wheat_seed_image = pygame.image.load(os.path.join(item_sprites_seed_path, "wheat_plant.png")).convert_alpha()
            tomato_seed_image = pygame.image.load(os.path.join(item_sprites_seed_path, "tomato_plant.png")).convert_alpha()
            
            # Создаем экземпляры семян для магазина
            wheat_seed = Seed("Семена пшеницы", wheat_seed_image, "wheat")
            tomato_seed = Seed("Семена томатов", tomato_seed_image, "tomato")
            
            # Добавляем в магазин семена (только для покупки)
            items.append(ShopItem(wheat_seed, 20, 0))  # sell_price=0 - нельзя продать
            items.append(ShopItem(tomato_seed, 30, 0))  # sell_price=0 - нельзя продать
            
            # Загружаем изображения растений (только для продажи)
            wheat_plant_image = pygame.image.load(os.path.join(item_sprites_plants, "wheat.png")).convert_alpha()
            tomato_plant_image = pygame.image.load(os.path.join(item_sprites_plants, "tomato.png")).convert_alpha()
            
            # Создаем экземпляры растений для продажи
            wheat_plant = Item("Пшеница", wheat_plant_image, "plant")
            tomato_plant = Item("Томаты", tomato_plant_image, "plant")
            
            # Добавляем растения (только для продажи - buy_price=0)
            items.append(ShopItem(wheat_plant, 0, 100))  # Цена продажи 100
            items.append(ShopItem(tomato_plant, 0, 150))  # Цена продажи 150
            
        except Exception as e:
            print(f"Ошибка при создании предметов для магазина: {e}")
            # Создаем заглушки для растений
            wheat_plant_image = pygame.Surface((32, 32))
            wheat_plant_image.fill((210, 180, 140))
            tomato_plant_image = pygame.Surface((32, 32))
            tomato_plant_image.fill((255, 99, 71))
            
            wheat_plant = Item("Пшеница", wheat_plant_image, "plant")
            tomato_plant = Item("Томаты", tomato_plant_image, "plant")
            
            items.append(ShopItem(wheat_plant, 0, 100))
            items.append(ShopItem(tomato_plant, 0, 150))
        
        return items

    def is_player_in_range(self):
        """Проверяет, находится ли игрок в радиусе действия магазина"""
        # Обновляем позицию магазина если она еще не установлена
        if not self.position_set:
            self.set_position_from_spawn()
        player = self.game_manager.player
        distance = ((player.rect.centerx - self.shop_x) ** 2 +
                   (player.rect.centery - self.shop_y) ** 2) ** 0.5
        return distance <= self.shop_range

    def handle_input(self, keys, events):
        """Обработка ввода для магазина"""
        if not self.is_open:
            # Проверяем, нужно ли показать подсказку об открытии магазина
            if self.is_player_in_range():
                # Обработка открытия магазина
                for event in events:
                    if event.type == pygame.KEYDOWN and event.key == pygame.K_e:
                        self.toggle_shop()
                        return True 
            return False
        # Обработка ввода когда магазин открыт
        for event in events:
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    self.toggle_shop()
                    return True
                elif event.key == pygame.K_TAB:
                    self.switch_tab()
                    return True
                elif event.key == pygame.K_UP:
                    self.selected_item_index = max(0, self.selected_item_index - 1)
                    return True
                elif event.key == pygame.K_DOWN:
                    max_index = len(self.get_current_items()) - 1
                    self.selected_item_index = min(max_index, self.selected_item_index + 1)
                    return True
                elif event.key == pygame.K_RETURN or event.key == pygame.K_SPACE:
                    self.execute_transaction()
                    return True
        return False

    def get_current_items(self):
        """Возвращает список предметов для текущей вкладки"""
        if self.current_tab == "buy":
            # Возвращаем только предметы для покупки (buy_price > 0)
            return [item for item in self.shop_items if item.buy_price > 0]
        else:  # sell tab
            # Возвращаем только предметы для продажи (sell_price > 0 и buy_price == 0)
            return [item.item for item in self.shop_items if item.sell_price > 0 and item.buy_price == 0]

    def switch_tab(self):
        """Переключение между вкладками покупки и продажи"""
        self.current_tab = "sell" if self.current_tab == "buy" else "buy"
        self.selected_item_index = 0
        self.scroll_offset = 0

    def execute_transaction(self):
        """Выполнение покупки или продажи"""
        items = self.get_current_items()
        if not items or self.selected_item_index >= len(items):
            return
        if self.current_tab == "buy":
            self.buy_item(items[self.selected_item_index])
        else:
            self.sell_item(items[self.selected_item_index])

    def buy_item(self, shop_item):
        player = self.game_manager.player
        if player.coins >= shop_item.buy_price:
            player.remove_coins(shop_item.buy_price)
            if hasattr(self.game_manager, 'inventory_manager'):
                # Создаем копию предмета с начальным количеством
                new_item = type(shop_item.item)(shop_item.item.name, shop_item.item.image, shop_item.item.type)
                # Копируем все атрибуты из исходного предмета
                for attr, value in shop_item.item.__dict__.items():
                    if attr not in ['name', 'image', 'type', 'stackable', 'max_stack', 'quantity']:
                        setattr(new_item, attr, value)
                new_item.quantity = 5  # Например, покупаем 5 семян за раз
                
                success = self.game_manager.inventory_manager.add_item_to_inventory(new_item)
                if not success:
                    player.add_coins(shop_item.buy_price)

    def sell_item(self, item):
        """Продажа предмета из инвентаря игрока"""
        if not item:
            print("Ошибка: Предмет не указан")
            return

        # Находим соответствующий товар в магазине для определения цены
        shop_item = None
        for si in self.shop_items:
            if si.item.name == item.name:
                shop_item = si
                break

        if not shop_item:
            print("Этот предмет нельзя продать в магазине")
            return

        # Проверяем, есть ли InventoryManager
        if not hasattr(self.game_manager, 'inventory_manager'):
            print("Ошибка: InventoryManager не найден")
            return

        # Удаляем предмет из инвентаря через InventoryManager
        inventory_manager = self.game_manager.inventory_manager
        if hasattr(inventory_manager, 'remove_item_from_inventory'):
            success = inventory_manager.remove_item_from_inventory(item)
            if success:
                # Начисляем деньги игроку
                self.game_manager.player.add_coins(shop_item.sell_price)
                print(f"Продан предмет: {item.name} за {shop_item.sell_price} монет")
            else:
                print("Не удалось продать предмет (предмет не найден в инвентаре)")
        else:
            print("Ошибка: У InventoryManager нет метода remove_item_from_inventory")

    def draw(self, screen):
        """Отрисовка магазина"""
        # Отрисовка подсказки об открытии магазина
        if not self.is_open and self.is_player_in_range():
            self.draw_shop_hint(screen)
        # Отрисовка окна магазина
        if self.is_open:
            self.draw_shop_window(screen)

    def draw_shop_hint(self, screen):
        """Отрисовка подсказки об открытии магазина"""
        hint_text = "Нажмите E для открытия магазина"
        text_surface = self.font.render(hint_text, True, (255, 255, 255))
        # Позиционируем текст по центру экрана внизу
        text_rect = text_surface.get_rect()
        text_rect.centerx = screen.get_width() // 2
        text_rect.y = screen.get_height() - 150
        # Фон для текста
        bg_rect = text_rect.inflate(20, 10)
        pygame.draw.rect(screen, (0, 0, 0, 180), bg_rect, border_radius=5)
        screen.blit(text_surface, text_rect)

    def draw_shop_window(self, screen):
        """Отрисовка окна магазина"""
        # Размеры окна магазина
        window_width = 600
        window_height = 400
        window_x = (screen.get_width() - window_width) // 2
        window_y = (screen.get_height() - window_height) // 2
        # Фон окна
        pygame.draw.rect(screen, (40, 40, 40), (window_x, window_y, window_width, window_height), border_radius=10)
        pygame.draw.rect(screen, (255, 255, 255), (window_x, window_y, window_width, window_height), 3, border_radius=10)
        # Заголовок
        title = "МАГАЗИН"
        title_surface = self.font.render(title, True, (255, 255, 255))
        title_rect = title_surface.get_rect(centerx=window_x + window_width // 2, y=window_y + 10)
        screen.blit(title_surface, title_rect)
        # Вкладки
        self.draw_tabs(screen, window_x, window_y + 50, window_width)
        # Список предметов
        self.draw_item_list(screen, window_x, window_y + 100, window_width, window_height - 150)
        # Инструкции
        instructions = [
            "↑/↓ - выбор предмета",
            "ENTER/SPACE - купить/продать",
            "TAB - сменить вкладку",
            "E - закрыть"
        ]
        y_offset = window_y + window_height - 80
        for instruction in instructions:
            text = self.small_font.render(instruction, True, (200, 200, 200))
            screen.blit(text, (window_x + 10, y_offset))
            y_offset += 15

    def draw_tabs(self, screen, x, y, width):
        """Отрисовка вкладок магазина"""
        tab_width = width // 2
        # Вкладка покупки
        buy_color = (60, 60, 60) if self.current_tab == "buy" else (30, 30, 30)
        pygame.draw.rect(screen, buy_color, (x, y, tab_width, 40), border_radius=5)
        if self.current_tab == "buy":
            pygame.draw.rect(screen, (0, 255, 0), (x, y, tab_width, 40), 2, border_radius=5)
        buy_text = self.font.render("ПОКУПКА", True, (255, 255, 255))
        buy_rect = buy_text.get_rect(center=(x + tab_width // 2, y + 20))
        screen.blit(buy_text, buy_rect)
        # Вкладка продажи
        sell_color = (60, 60, 60) if self.current_tab == "sell" else (30, 30, 30)
        pygame.draw.rect(screen, sell_color, (x + tab_width, y, tab_width, 40), border_radius=5)
        if self.current_tab == "sell":
            pygame.draw.rect(screen, (0, 255, 0), (x + tab_width, y, tab_width, 40), 2, border_radius=5)
        sell_text = self.font.render("ПРОДАЖА", True, (255, 255, 255))
        sell_rect = sell_text.get_rect(center=(x + tab_width + tab_width // 2, y + 20))
        screen.blit(sell_text, sell_rect)

    def draw_item_list(self, screen, x, y, width, height):
        """Отрисовка списка предметов"""
        items = self.get_current_items()
        if not items:
            no_items_text = "Нет предметов" if self.current_tab == "sell" else "Магазин пуст"
            text = self.font.render(no_items_text, True, (200, 200, 200))
            text_rect = text.get_rect(center=(x + width // 2, y + height // 2))
            screen.blit(text, text_rect)
            return
        item_height = 60
        visible_items = height // item_height
        for i in range(min(visible_items, len(items))):
            item_index = i + self.scroll_offset
            if item_index >= len(items):
                break
            item_y = y + i * item_height
            # Выделение выбранного предмета
            if item_index == self.selected_item_index:
                pygame.draw.rect(screen, (80, 80, 80), (x + 10, item_y, width - 20, item_height - 5), border_radius=5)
            if self.current_tab == "buy":
                self.draw_shop_item(screen, self.shop_items[item_index], x + 20, item_y, width - 40)
            else:
                self.draw_inventory_item(screen, items[item_index], x + 20, item_y, width - 40)

    def draw_shop_item(self, screen, shop_item, x, y, width):
        """Отрисовка предмета в магазине"""
        # Изображение предмета
        if hasattr(shop_item.item, 'image') and shop_item.item.image:
            item_image = pygame.transform.scale(shop_item.item.image, (40, 40))
            screen.blit(item_image, (x, y + 10))
        else:
            # Заглушка
            pygame.draw.rect(screen, (100, 100, 100), (x, y + 10, 40, 40))
        # Название предмета
        name_text = self.font.render(shop_item.item.name, True, (255, 255, 255))
        screen.blit(name_text, (x + 60, y + 10))
        # Цена
        price_text = f"Цена: {shop_item.buy_price} монет"
        price_surface = self.small_font.render(price_text, True, (255, 215, 0))
        screen.blit(price_surface, (x + 60, y + 35))

    def draw_inventory_item(self, screen, item, x, y, width):
        """Отрисовка предмета из инвентаря для продажи"""
        # Изображение предмета
        if hasattr(item, 'image') and item.image:
            item_image = pygame.transform.scale(item.image, (40, 40))
            screen.blit(item_image, (x, y + 10))
        else:
            # Заглушка
            pygame.draw.rect(screen, (100, 100, 100), (x, y + 10, 40, 40))
        # Название предмета
        name_text = self.font.render(item.name, True, (255, 255, 255))
        screen.blit(name_text, (x + 60, y + 10))
        # Цена продажи
        shop_item = None
        for si in self.shop_items:
            if si.item.name == item.name:
                shop_item = si
                break
        if shop_item:
            price_text = f"Цена: {shop_item.sell_price} монет"
            price_surface = self.small_font.render(price_text, True, (0, 255, 0))
        else:
            price_text = "Нельзя продать"
            price_surface = self.small_font.render(price_text, True, (255, 0, 0))
        screen.blit(price_surface, (x + 60, y + 35))


==================== tempCodeRunnerFile.py ====================

open


==================== tilemap.py ====================

import pygame


class TiledMap:
    def __init__(self, tmx_data):
        self.tmx_data = tmx_data
        self.width = tmx_data.width * tmx_data.tilewidth
        self.height = tmx_data.height * tmx_data.tileheight
        self.render_surface = self.make_map()

    def render(self, surface, pos=(0, 0)):
        surface.blit(self.render_surface, pos)

    def make_map(self):
        temp_surface = pygame.Surface((self.width, self.height))
        temp_surface.set_colorkey((0, 0, 0))

        # Отрисовка каждого слоя
        for layer in self.tmx_data.visible_layers:
            if hasattr(layer, 'data'):  # Это слой тайлов
                for x, y, gid in layer:
                    tile = self.tmx_data.get_tile_image_by_gid(gid)
                    if tile:
                        temp_surface.blit(
                            tile,
                            (x * self.tmx_data.tilewidth,
                             y * self.tmx_data.tileheight)
                        )

        return temp_surface

    def get_tile_properties(self, x, y, layer):
        """Получение свойств тайла по координатам"""
        tile = self.tmx_data.get_tile_properties(x, y, layer)
        return tile if tile else None

    def get_object_layer(self, layer_name):
        """Получение слоя объектов по имени"""
        return self.tmx_data.get_layer_by_name(layer_name)



==================== ui.py ====================

import pygame
from settings import WHITE, BLACK, GRAY, DARK_GRAY


class Button:
    def __init__(self, x, y, width, height, text, font_size=32):
        self.rect = pygame.Rect(x, y, width, height)
        self.text = text
        self.font = pygame.font.Font(None, font_size)
        self.is_hovered = False

    def draw(self, surface):
        color = DARK_GRAY if self.is_hovered else GRAY
        pygame.draw.rect(surface, color, self.rect)
        pygame.draw.rect(surface, BLACK, self.rect, 2)

        text_surface = self.font.render(self.text, True, WHITE)
        text_rect = text_surface.get_rect(center=self.rect.center)
        surface.blit(text_surface, text_rect)

    def handle_event(self, event):
        if event.type == pygame.MOUSEMOTION:
            self.is_hovered = self.rect.collidepoint(event.pos)
        elif event.type == pygame.MOUSEBUTTONDOWN:
            if self.is_hovered:
                return True
        return False


class Slider:
    def __init__(self, x, y, width, height, start_value=0.7):
        self.rect = pygame.Rect(x, y, width, height)
        self.value = start_value
        self.grabbed = False

    def draw(self, surface):
        pygame.draw.rect(surface, GRAY, self.rect)
        pygame.draw.rect(surface, BLACK, self.rect, 2)

        slider_x = self.rect.x + (self.rect.width * self.value) - 5
        slider_rect = pygame.Rect(slider_x, self.rect.y - 5, 10, self.rect.height + 10)
        pygame.draw.rect(surface, WHITE, slider_rect)
        pygame.draw.rect(surface, BLACK, slider_rect, 2)

    def handle_event(self, event):
        if event.type == pygame.MOUSEBUTTONDOWN:
            if self.rect.collidepoint(event.pos):
                self.grabbed = True
        elif event.type == pygame.MOUSEBUTTONUP:
            self.grabbed = False
        elif event.type == pygame.MOUSEMOTION and self.grabbed:
            relative_x = event.pos[0] - self.rect.x
            self.value = max(0, min(1, relative_x / self.rect.width))
            return True
        return False



==================== __init__.py ====================

"""
Happy Farm Game Package
Version: 1.0.0
"""

# Константы игры
GAME_TITLE = "Happy Farm"
GAME_VERSION = "1.0.0"

# Размеры окна по умолчанию
DEFAULT_WINDOW_WIDTH = 800
DEFAULT_WINDOW_HEIGHT = 600

# Настройки игрока
PLAYER_SPEED = 200
PLAYER_SIZE = (32, 32)

# Настройки карты
TILE_SIZE = 32
MAP_LAYERS = {
    'ground': 0,
    'buildings': 1,
    'objects': 2,
    'overlay': 3
}

# Настройки игры по умолчанию
DEFAULT_SETTINGS = {
    'sound_volume': 0.7,
    'music_volume': 0.5,
    'fullscreen': False,
    'fps_limit': 60
}

# Пути к ресурсам
RESOURCE_PATHS = {
    'maps': 'maps',
    'sprites': 'sprites',
    'sounds': 'sounds',
    'music': 'music',
    'fonts': 'fonts'
}


